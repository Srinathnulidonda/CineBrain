<!-- Dynamic Rating Badge Component -->
<span class="rating-badge d-inline-flex align-items-center" data-rating="" data-vote-count="">
    <!-- Rating will be populated dynamically -->
</span>

<script>
    class RatingBadge {
        constructor(element, rating, voteCount = null, source = 'tmdb') {
            this.element = element;
            this.rating = parseFloat(rating) || 0;
            this.voteCount = parseInt(voteCount) || 0;
            this.source = source;

            this.init();
        }

        init() {
            this.element.dataset.rating = this.rating;
            this.element.dataset.voteCount = this.voteCount;
            this.render();
        }

        render() {
            const badgeClass = this.getBadgeClass();
            const ratingText = this.getRatingText();
            const icon = this.getRatingIcon();

            this.element.className = `rating-badge d-inline-flex align-items-center ${badgeClass} px-2 py-1 rounded-pill small fw-semibold`;
            this.element.innerHTML = `
      <i class="${icon} me-1" style="font-size: 0.8rem;"></i>
      <span class="rating-text">${ratingText}</span>
      ${this.voteCount > 0 ? `<span class="vote-count ms-1 opacity-75">(${this.formatVoteCount()})</span>` : ''}
    `;

            // Add tooltip for detailed info
            this.element.title = this.getTooltipText();
        }

        getBadgeClass() {
            if (this.rating >= 8.0) {
                return 'bg-success text-white'; // Excellent (Green)
            } else if (this.rating >= 7.0) {
                return 'bg-warning text-dark'; // Good (Yellow/Gold)
            } else if (this.rating >= 6.0) {
                return 'bg-info text-white'; // Average (Blue)
            } else if (this.rating >= 4.0) {
                return 'bg-secondary text-white'; // Below Average (Gray)
            } else {
                return 'bg-danger text-white'; // Poor (Red)
            }
        }

        getRatingIcon() {
            if (this.source === 'imdb') {
                return 'fas fa-star';
            } else if (this.source === 'mal') {
                return 'fas fa-heart'; // MyAnimeList uses hearts
            } else {
                return 'fas fa-star'; // TMDB default
            }
        }

        getRatingText() {
            if (this.rating === 0) {
                return 'N/A';
            }

            // Format based on source
            if (this.source === 'imdb') {
                return this.rating.toFixed(1) + '/10';
            } else if (this.source === 'mal') {
                return this.rating.toFixed(1) + '/10';
            } else {
                return this.rating.toFixed(1) + '/10'; // TMDB
            }
        }

        formatVoteCount() {
            if (this.voteCount >= 1000000) {
                return (this.voteCount / 1000000).toFixed(1) + 'M';
            } else if (this.voteCount >= 1000) {
                return (this.voteCount / 1000).toFixed(1) + 'K';
            }
            return this.voteCount.toString();
        }

        getTooltipText() {
            const ratingLevel = this.getRatingLevel();
            return `${ratingLevel} - ${this.rating.toFixed(1)}/10 based on ${this.voteCount.toLocaleString()} votes`;
        }

        getRatingLevel() {
            if (this.rating >= 8.0) return 'Excellent';
            if (this.rating >= 7.0) return 'Good';
            if (this.rating >= 6.0) return 'Average';
            if (this.rating >= 4.0) return 'Below Average';
            return 'Poor';
        }

        // Update rating dynamically
        updateRating(newRating, newVoteCount = null) {
            this.rating = parseFloat(newRating) || 0;
            if (newVoteCount !== null) {
                this.voteCount = parseInt(newVoteCount) || 0;
            }
            this.render();
        }
    }

    // Auto-initialize rating badges
    document.addEventListener('DOMContentLoaded', () => {
        const ratingBadges = document.querySelectorAll('.rating-badge[data-auto-init="true"]');
        ratingBadges.forEach(badge => {
            const rating = badge.dataset.rating;
            const voteCount = badge.dataset.voteCount;
            const source = badge.dataset.source || 'tmdb';
            new RatingBadge(badge, rating, voteCount, source);
        });
    });

    // Global function for creating rating badges
    window.createRatingBadge = function (element, rating, voteCount, source) {
        return new RatingBadge(element, rating, voteCount, source);
    };
</script>

<style>
    .rating-badge {
        font-size: 0.75rem;
        line-height: 1.2;
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(4px);
        transition: all 0.2s ease;
    }

    .rating-badge:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .rating-badge .vote-count {
        font-size: 0.65rem;
    }
</style>