<!-- CineBrain Mini Content Card Component -->
<div class="card-mini" data-content-id="" data-content-type="">
    <img src="" alt="" class="mini-poster" loading="lazy">
    <div class="mini-content">
        <h6 class="mini-title"></h6>
        <div class="mini-meta">
            <span class="mini-rating"></span>
            <span class="mini-type"></span>
            <span class="mini-year"></span>
        </div>
        <div class="mini-progress" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
            <span class="progress-text"></span>
        </div>
    </div>
    <div class="mini-actions">
        <button class="btn btn-sm btn-outline-light mini-play" data-action="play-trailer" title="Play Trailer">
            <i class="bi bi-play-fill"></i>
        </button>
        <button class="btn btn-sm btn-outline-light mini-remove" data-action="remove-item" title="Remove" style="display: none;">
            <i class="bi bi-x"></i>
        </button>
    </div>
</div>

<script>
(function() {
    'use strict';
    
    // Mini Card Class
    class MiniCard {
        constructor(element, data, options = {}) {
            this.element = element;
            this.data = data;
            this.options = {
                showProgress: false,
                showRemove: false,
                contextType: 'default', // 'watchlist', 'favorites', 'history'
                ...options
            };
            this.init();
        }
        
        init() {
            this.render();
            this.setupEventListeners();
            this.loadAdditionalData();
        }
        
        render() {
            if (!this.data) return;
            
            const {
                id,
                title,
                content_type,
                poster_path,
                rating,
                release_date,
                watch_progress,
                last_watched
            } = this.data;
            
            // Set data attributes
            this.element.setAttribute('data-content-id', id);
            this.element.setAttribute('data-content-type', content_type);
            
            // Update poster image
            const miniPoster = this.element.querySelector('.mini-poster');
            if (poster_path) {
                const posterUrl = poster_path.startsWith('http') 
                    ? poster_path 
                    : `https://image.tmdb.org/t/p/w185${poster_path}`;
                miniPoster.src = posterUrl;
                miniPoster.alt = title;
            } else {
                miniPoster.src = '/images/placeholder-poster.jpg';
                miniPoster.alt = 'No poster available';
            }
            
            // Update title
            const miniTitle = this.element.querySelector('.mini-title');
            miniTitle.textContent = title;
            miniTitle.title = title;
            
            // Update rating
            const miniRating = this.element.querySelector('.mini-rating');
            if (rating) {
                miniRating.innerHTML = `<i class="bi bi-star-fill text-warning"></i> ${Number(rating).toFixed(1)}`;
            } else {
                miniRating.textContent = 'NR';
            }
            
            // Update type
            const miniType = this.element.querySelector('.mini-type');
            miniType.textContent = content_type.toUpperCase();
            miniType.className = `mini-type type-badge ${content_type}`;
            
            // Update year
            const miniYear = this.element.querySelector('.mini-year');
            if (release_date) {
                miniYear.textContent = new Date(release_date).getFullYear();
            } else {
                miniYear.textContent = 'TBA';
            }
            
            // Update progress if available
            if (this.options.showProgress && (watch_progress || last_watched)) {
                this.updateProgress(watch_progress, last_watched);
            }
            
            // Show remove button if needed
            if (this.options.showRemove) {
                const removeBtn = this.element.querySelector('.mini-remove');
                removeBtn.style.display = 'block';
            }
            
            // Update action buttons with content ID
            this.element.querySelectorAll('[data-action]').forEach(btn => {
                btn.setAttribute('data-content-id', id);
            });
        }
        
        updateProgress(watchProgress, lastWatched) {
            const progressContainer = this.element.querySelector('.mini-progress');
            const progressFill = this.element.querySelector('.progress-fill');
            const progressText = this.element.querySelector('.progress-text');
            
            if (watchProgress) {
                progressContainer.style.display = 'block';
                const percentage = Math.min(Math.max(watchProgress.percentage || 0, 0), 100);
                progressFill.style.width = `${percentage}%`;
                
                if (percentage > 0 && percentage < 100) {
                    progressText.textContent = `${Math.round(percentage)}% watched`;
                } else if (percentage >= 100) {
                    progressText.textContent = 'Completed';
                } else {
                    progressText.textContent = 'Not started';
                }
            } else if (lastWatched) {
                progressContainer.style.display = 'block';
                progressText.textContent = `Last watched: ${this.formatDate(lastWatched)}`;
            }
        }
        
        setupEventListeners() {
            // Card click for main content view
            this.element.addEventListener('click', (e) => {
                if (!e.target.closest('[data-action]')) {
                    this.viewContent();
                }
            });
            
            // Action button handlers
            const playBtn = this.element.querySelector('[data-action="play-trailer"]');
            const removeBtn = this.element.querySelector('[data-action="remove-item"]');
            
            if (playBtn) {
                playBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.playTrailer();
                });
            }
            
            if (removeBtn) {
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.removeItem();
                });
            }
            
            // Hover effects
            this.element.addEventListener('mouseenter', this.handleMouseEnter.bind(this));
            this.element.addEventListener('mouseleave', this.handleMouseLeave.bind(this));
        }
        
        handleMouseEnter() {
            // Add hover class for custom styling
            this.element.classList.add('mini-card-hover');
        }
        
        handleMouseLeave() {
            this.element.classList.remove('mini-card-hover');
        }
        
        async loadAdditionalData() {
            // Load additional data like user interactions
            const token = localStorage.getItem('cinebrain_token');
            if (!token) return;
            
            try {
                const response = await fetch(`https://backend-app-970m.onrender.com/api/content/${this.data.id}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const detailedData = await response.json();
                    this.data = { ...this.data, ...detailedData };
                    this.updateWithDetailedData();
                }
            } catch (error) {
                console.error('Error loading additional data:', error);
            }
        }
        
        updateWithDetailedData() {
            // Update any additional elements with detailed data
            const miniMeta = this.element.querySelector('.mini-meta');
            
            // Add genre information if available
            if (this.data.genres && this.data.genres.length > 0) {
                const genreSpan = document.createElement('span');
                genreSpan.className = 'mini-genre';
                genreSpan.textContent = this.data.genres[0]; // Show first genre
                miniMeta.appendChild(genreSpan);
            }
        }
        
        viewContent() {
            // Record view interaction
            this.recordInteraction('view');
            
            // Navigate to details page
            window.location.href = `/content/details.html?id=${this.data.id}`;
        }
        
        async playTrailer() {
            try {
                // Record interaction
                this.recordInteraction('view');
                
                // Get content details if we don't have trailer info
                if (!this.data.youtube_trailer) {
                    const response = await fetch(`https://backend-app-970m.onrender.com/api/content/${this.data.id}`);
                    if (response.ok) {
                        const contentData = await response.json();
                        this.data.youtube_trailer = contentData.youtube_trailer;
                    }
                }
                
                if (this.data.youtube_trailer) {
                    this.showTrailerModal(this.data.youtube_trailer, this.data.title);
                } else {
                    this.showToast('Trailer not available', 'info');
                }
            } catch (error) {
                console.error('Error playing trailer:', error);
                this.showToast('Failed to load trailer', 'error');
            }
        }
        
        async removeItem() {
            if (!confirm(`Remove "${this.data.title}" from ${this.options.contextType}?`)) {
                return;
            }
            
            const token = localStorage.getItem('cinebrain_token');
            if (!token) return;
            
            try {
                let endpoint = '';
                let interactionType = '';
                
                switch (this.options.contextType) {
                    case 'watchlist':
                        interactionType = 'remove_watchlist';
                        break;
                    case 'favorites':
                        interactionType = 'remove_favorite';
                        break;
                    default:
                        return;
                }
                
                const response = await fetch('https://backend-app-970m.onrender.com/api/interactions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content_id: this.data.id,
                        interaction_type: interactionType
                    })
                });
                
                if (response.ok) {
                    // Animate removal
                    this.element.style.transform = 'translateX(-100%)';
                    this.element.style.opacity = '0';
                    
                    setTimeout(() => {
                        this.element.remove();
                    }, 300);
                    
                    this.showToast(`Removed from ${this.options.contextType}`, 'success');
                } else {
                    throw new Error('Failed to remove item');
                }
            } catch (error) {
                console.error('Error removing item:', error);
                this.showToast('Failed to remove item', 'error');
            }
        }
        
        showTrailerModal(youtubeUrl, title) {
            // Create and show trailer modal
            const modal = document.createElement('div');
            modal.className = 'trailer-modal';
            modal.innerHTML = `
                <div class="modal-backdrop" onclick="this.parentElement.remove()"></div>
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">${title} - Trailer</h5>
                        <button class="modal-close" onclick="this.closest('.trailer-modal').remove()">
                            <i class="bi bi-x-lg"></i>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="video-container">
                            <iframe src="${youtubeUrl.replace('watch?v=', 'embed/')}" 
                                    frameborder="0" allowfullscreen></iframe>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            setTimeout(() => modal.classList.add('show'), 10);
        }
        
        showToast(message, type) {
            if (window.App && window.App.showToast) {
                window.App.showToast(message, type);
            } else {
                alert(message); // Fallback
            }
        }
        
        async recordInteraction(type) {
            const token = localStorage.getItem('cinebrain_token');
            if (!token) return;
            
            try {
                await fetch('https://backend-app-970m.onrender.com/api/interactions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content_id: this.data.id,
                        interaction_type: type
                    })
                });
            } catch (error) {
                console.error('Error recording interaction:', error);
            }
        }
        
        formatDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            if (diffDays === 1) {
                return 'Yesterday';
            } else if (diffDays < 7) {
                return `${diffDays} days ago`;
            } else if (diffDays < 30) {
                return `${Math.ceil(diffDays / 7)} weeks ago`;
            } else {
                return date.toLocaleDateString();
            }
        }
    }
    
    // Global function to create mini card with data
    window.createMiniCard = function(data, container, options = {}) {
        const cardHTML = `
            <div class="card-mini" data-content-id="${data.id}" data-content-type="${data.content_type}">
                <img src="" alt="" class="mini-poster" loading="lazy">
                <div class="mini-content">
                    <h6 class="mini-title"></h6>
                    <div class="mini-meta">
                        <span class="mini-rating"></span>
                        <span class="mini-type"></span>
                        <span class="mini-year"></span>
                    </div>
                    <div class="mini-progress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill"></div>
                        </div>
                        <span class="progress-text"></span>
                    </div>
                </div>
                <div class="mini-actions">
                    <button class="btn btn-sm btn-outline-light mini-play" data-action="play-trailer" title="Play Trailer">
                        <i class="bi bi-play-fill"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-light mini-remove" data-action="remove-item" title="Remove" style="display: none;">
                        <i class="bi bi-x"></i>
                    </button>
                </div>
            </div>
        `;
        
        if (container) {
            container.insertAdjacentHTML('beforeend', cardHTML);
            const newCard = container.lastElementChild;
            new MiniCard(newCard, data, options);
            return newCard;
        } else {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHTML;
            const cardElement = tempDiv.firstElementChild;
            new MiniCard(cardElement, data, options);
            return cardElement;
        }
    };
    
    // Auto-initialize mini cards
    function initMiniCards() {
        document.querySelectorAll('.card-mini:not([data-initialized])').forEach(cardElement => {
            cardElement.setAttribute('data-initialized', 'true');
            
            const contentData = cardElement.dataset.contentData;
            if (contentData) {
                try {
                    const data = JSON.parse(contentData);
                    const options = JSON.parse(cardElement.dataset.options || '{}');
                    new MiniCard(cardElement, data, options);
                } catch (error) {
                    console.error('Error parsing mini card data:', error);
                }
            }
        });
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initMiniCards);
    } else {
        initMiniCards();
    }
    
})();
</script>

<style>
.card-mini {
    display: flex;
    align-items: center;
    gap: var(--space-md);
    padding: var(--space-md);
    background-color: var(--bg-secondary);
    border-radius: var(--radius-lg);
    transition: all var(--transition-fast) var(--ease-cinematic);
    cursor: pointer;
    border: 1px solid transparent;
}

.card-mini:hover,
.card-mini.mini-card-hover {
    background-color: var(--bg-tertiary);
    transform: translateX(0.25rem);
    border-color: var(--border-primary);
}

.mini-poster {
    width: 3rem;
    height: 4.5rem;
    object-fit: cover;
    border-radius: var(--radius-sm);
    flex-shrink: 0;
}

.mini-content {
    flex: 1;
    min-width: 0;
}

.mini-title {
    font-size: 0.875rem;
    font-weight: 600;
    margin: 0 0 0.25rem 0;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.mini-meta {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: 0.25rem;
}

.mini-rating {
    color: var(--vip-gold);
    font-weight: 600;
}

.mini-genre {
    background: rgba(255, 255, 255, 0.1);
    color: var(--text-secondary);
    padding: 0.125rem 0.375rem;
    border-radius: 1rem;
    font-size: 0.625rem;
}

.mini-progress {
    margin-top: 0.25rem;
}

.progress-bar {
    width: 100%;
    height: 0.25rem;
    background: var(--bg-tertiary);
    border-radius: 0.125rem;
    overflow: hidden;
    margin-bottom: 0.25rem;
}

.progress-fill {
    height: 100%;
    background: var(--accent-primary);
    transition: width var(--transition-base) ease;
}

.progress-text {
    font-size: 0.625rem;
    color: var(--text-muted);
}

.mini-actions {
    display: flex;
    gap: 0.25rem;
    flex-shrink: 0;
}

.mini-actions .btn {
    padding: 0.25rem;
    width: 1.75rem;
    height: 1.75rem;
    font-size: 0.75rem;
}

.mini-remove {
    color: var(--cinema-red) !important;
    border-color: var(--cinema-red) !important;
}

.mini-remove:hover {
    background-color: var(--cinema-red) !important;
    color: white !important;
}

@media (max-width: 767.98px) {
    .card-mini {
        padding: var(--space-sm);
        gap: var(--space-sm);
    }
    
    .mini-poster {
        width: 2.5rem;
        height: 3.75rem;
    }
    
    .mini-title {
        font-size: 0.8125rem;
    }
    
    .mini-meta {
        font-size: 0.6875rem;
    }
}
</style>