3. system.js
class SystemMonitor {
    constructor(dashboard) {
        this.dashboard = dashboard;
        this.apiBase = dashboard.apiBase;

        this.monitoring = {
            refreshRate: 8000,
            systemTimer: null,
            serviceTimer: null,
            alertsTimer: null,
            notificationTimer: null,
            healthTimer: null,
            activityTimer: null
        };

        this.systemData = {
            systemMonitoring: null,
            serviceStatus: null,
            systemHealth: null,
            adminActivity: null,
            alerts: [],
            notifications: [],
            lastAlertCheck: null,
            lastNotificationCheck: null,
            lastNotificationUpdate: null
        };

        this.processedAlerts = new Set();
        this.processedNotifications = new Set();
        this.notificationQueue = [];

        this.isUpdatingNotifications = false;
        this.lastNotificationHash = '';
        this.notificationUpdateDebounce = null;

        this.elements = this.initializeElements();
    }

    async init() {
        this.setupEventListeners();
        this.setupNotificationSystem();
        this.systemData.lastAlertCheck = new Date();
        this.systemData.lastNotificationCheck = new Date();
        this.startSystemMonitoringNew();
        await this.loadAllSystemDataNew();
    }

    initializeElements() {
        return {
            mainStatusDot: document.getElementById('mainStatusDot'),
            mainStatusText: document.getElementById('mainStatusText'),
            dbStatus: document.getElementById('dbStatus'),
            cacheStatus: document.getElementById('cacheStatus'),
            apiStatus: document.getElementById('apiStatus'),
            dbHealthStatus: document.getElementById('dbHealthStatus'),
            cacheHealthStatus: document.getElementById('cacheHealthStatus'),
            servicesHealthStatus: document.getElementById('servicesHealthStatus'),
            performanceHealthStatus: document.getElementById('performanceHealthStatus'),
            dbConnectionStatus: document.getElementById('dbConnectionStatus'),
            dbResponseTime: document.getElementById('dbResponseTime'),
            dbConnections: document.getElementById('dbConnections'),
            cacheType: document.getElementById('cacheType'),
            cacheHitRate: document.getElementById('cacheHitRate'),
            cacheMemory: document.getElementById('cacheMemory'),
            tmdbStatus: document.getElementById('tmdbStatus'),
            youtubeStatus: document.getElementById('youtubeStatus'),
            cloudinaryStatus: document.getElementById('cloudinaryStatus'),
            cpuUsage: document.getElementById('cpuUsage'),
            memoryUsage: document.getElementById('memoryUsage'),
            diskUsage: document.getElementById('diskUsage'),
            alertsSection: document.getElementById('alertsSection'),
            realTimeAlerts: document.getElementById('realTimeAlerts'),
            activeAlertsCount: document.getElementById('activeAlertsCount'),
            servicesStatusGrid: document.getElementById('servicesStatusGrid'),
            adminActivityMetrics: document.getElementById('adminActivityMetrics'),
            adminActivityStatus: document.getElementById('adminActivityStatus'),
            systemNotificationsList: document.getElementById('systemNotificationsList'),
            notificationDropdown: document.getElementById('notificationDropdown'),
            notificationDropdownContent: document.getElementById('notificationDropdownContent'),
            performanceIndicator: document.getElementById('performanceIndicator'),
            lastUpdate: document.getElementById('lastUpdate'),
            liveConnectionStatus: document.getElementById('liveConnectionStatus')
        };
    }

    setupEventListeners() {
        const quickHealthCheck = document.getElementById('quickHealthCheck');
        quickHealthCheck?.addEventListener('click', () => {
            this.performQuickHealthCheck();
            this.dashboard.hapticFeedback('medium');
        });

        const monitoringRefreshRate = document.getElementById('monitoringRefreshRate');
        monitoringRefreshRate?.addEventListener('change', (e) => {
            this.updateMonitoringRefreshRate(parseInt(e.target.value));
        });

        const dismissAllAlerts = document.getElementById('dismissAllAlerts');
        dismissAllAlerts?.addEventListener('click', () => {
            this.dismissAllAlerts();
        });

        const markAllNotificationsRead = document.getElementById('markAllNotificationsRead');
        markAllNotificationsRead?.addEventListener('click', () => {
            this.markAllNotificationsAsRead();
        });

        const markAllNotificationsReadBtn = document.getElementById('markAllNotificationsReadBtn');
        markAllNotificationsReadBtn?.addEventListener('click', () => {
            this.markAllNotificationsAsRead();
        });

        const notificationBell = document.getElementById('notificationBell');
        notificationBell?.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleNotificationDropdown();
        });

        const closeNotificationDropdown = document.getElementById('closeNotificationDropdown');
        closeNotificationDropdown?.addEventListener('click', () => {
            this.hideNotificationDropdown();
        });

        const viewAllNotificationsBtn = document.getElementById('viewAllNotificationsBtn');
        viewAllNotificationsBtn?.addEventListener('click', () => {
            window.location.href = '/admin/notifications.html';
            this.hideNotificationDropdown();
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.notification-dropdown') &&
                !e.target.closest('#notificationBell')) {
                this.hideNotificationDropdown();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isNotificationDropdownOpen()) {
                this.hideNotificationDropdown();
            }
        });
    }

    setupNotificationSystem() {
        setInterval(() => {
            this.processNotificationQueue();
        }, 1000);

        window.addEventListener('cinebrain-notification', (e) => {
            this.handleNewNotification(e.detail);
        });
    }

    startSystemMonitoringNew() {
        this.monitoring.systemTimer = setInterval(() => {
            this.loadSystemMonitoringData();
        }, 10000);

        setTimeout(() => {
            this.monitoring.alertsTimer = setInterval(() => {
                this.loadSupportAlerts();
            }, 12000);
        }, 2000);

        setTimeout(() => {
            this.monitoring.serviceTimer = setInterval(() => {
                this.loadServiceStatusData();
            }, 15000);
        }, 4000);

        setTimeout(() => {
            this.monitoring.activityTimer = setInterval(() => {
                this.loadAdminActivityData();
            }, 18000);
        }, 6000);

        setTimeout(() => {
            this.monitoring.healthTimer = setInterval(() => {
                this.loadSystemHealthData();
            }, 25000);
        }, 8000);

        setTimeout(() => {
            this.monitoring.notificationTimer = setInterval(() => {
                if (!this.isNotificationDropdownOpen()) {
                    this.loadAdminNotifications();
                }
            }, 20000);
        }, 10000);

        console.log('‚úÖ System monitoring started with simplified timing');
    }

    async loadAllSystemDataNew() {
        try {
            await Promise.allSettled([
                this.loadSystemMonitoringData(),
                this.loadServiceStatusData(),
                this.loadAdminActivityData(),
                this.loadSystemHealthData(),
                this.loadSupportAlerts(),
                this.loadAdminNotifications()
            ]);

            this.updateSystemStatusBarNew();
            this.updateLiveConnectionStatus();
        } catch (error) {
            console.error('Error loading system data:', error);
        }
    }

    async loadSystemMonitoringData() {
        try {
            const response = await this.dashboard.makeAuthenticatedRequest('/system-monitoring');
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.data) {
                    this.systemData.systemMonitoring = data.data;
                    this.updateSystemHealthCardsNew(data.data);
                    this.updateSystemStatusBarNew(data.data);

                    if (data.refresh_interval) {
                        this.updateElement('refreshInterval', `${data.refresh_interval}s`);
                    }
                }
            }
        } catch (error) {
            console.error('Error loading system monitoring:', error);
            this.updateSystemStatusBarNew({ status: 'error' });
        }
    }

    async loadServiceStatusData() {
        try {
            const response = await this.dashboard.makeAuthenticatedRequest('/service-status');
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.data) {
                    this.systemData.serviceStatus = data.data;
                    this.updateServicesDisplay(data.data);
                }
            }
        } catch (error) {
            console.error('Error loading service status:', error);
        }
    }

    async loadAdminActivityData() {
        try {
            const response = await this.dashboard.makeAuthenticatedRequest('/admin-activity');
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.data) {
                    this.systemData.adminActivity = data.data;
                    this.updateAdminActivityMetrics(data.data);
                }
            }
        } catch (error) {
            console.error('Error loading admin activity:', error);
        }
    }

    async loadSystemHealthData() {
        try {
            const response = await this.dashboard.makeAuthenticatedRequest('/admin/system-health');
            if (response.ok) {
                const data = await response.json();
                this.systemData.systemHealth = data;
                this.updateSystemHealth(data);
            }
        } catch (error) {
            console.error('Error loading system health:', error);
        }
    }

    async loadSupportAlerts() {
        try {
            const response = await this.dashboard.makeAuthenticatedRequest('/admin/support/alerts');
            if (response.ok) {
                const data = await response.json();
                if (data.success && data.alerts) {
                    const alerts = data.alerts;

                    alerts.forEach(alert => {
                        const alertId = alert.id || `${alert.type}-${alert.message}-${alert.created_at}`;
                        if (!this.processedAlerts.has(alertId)) {
                            this.processedAlerts.add(alertId);
                            this.handleNewAlert(alert);
                        }
                    });

                    if (this.processedAlerts.size > 100) {
                        const alertsArray = Array.from(this.processedAlerts);
                        this.processedAlerts = new Set(alertsArray.slice(-100));
                    }

                    this.systemData.alerts = alerts;
                    this.updateSystemAlertsNew(alerts);
                }
            }
        } catch (error) {
            console.error('Error loading support alerts:', error);
        }
    }

    async loadAdminNotifications() {
        if (this.isUpdatingNotifications) {
            console.log('Notification update already in progress, skipping...');
            return;
        }

        try {
            this.isUpdatingNotifications = true;

            const response = await this.dashboard.makeAuthenticatedRequest('/admin/notifications');
            if (response.ok) {
                const data = await response.json();

                let notifications = data.notifications || data.recent_notifications || [];

                notifications = await this.enhanceNotificationsWithSupportDataSimple(notifications);

                this.updateSystemNotificationsNew(data);
                this.updateNotificationDropdown(notifications);

                const newNotifications = notifications.filter(notif => {
                    const notifId = notif.id || `${notif.type}-${notif.created_at}`;
                    const isNew = !this.processedNotifications.has(notifId) && !notif.is_read;
                    if (isNew) {
                        this.processedNotifications.add(notifId);
                    }
                    return isNew;
                });

                if (newNotifications.length > 0 && this.processedNotifications.size > 10) {
                    newNotifications.forEach(notif => this.handleNewNotification(notif));
                }

                if (this.processedNotifications.size > 200) {
                    const notifsArray = Array.from(this.processedNotifications);
                    this.processedNotifications = new Set(notifsArray.slice(-100));
                }

                localStorage.setItem('cinebrain-admin-notifications', JSON.stringify(notifications.slice(0, 50)));

                console.log(`‚úÖ Loaded ${notifications.length} notifications`);

            } else {
                console.error('Failed to load notifications:', response.status);
                this.showNotificationError();
            }
        } catch (error) {
            console.error('Error loading admin notifications:', error);
            this.showNotificationError();
        } finally {
            this.isUpdatingNotifications = false;
        }
    }

    async enhanceNotificationsWithSupportDataSimple(baseNotifications) {
        const enhancedNotifications = [...baseNotifications];

        try {
            const existingIds = new Set(enhancedNotifications.map(n => n.id));

            if (this.dashboard.dashboardData.supportData) {
                const supportData = this.dashboard.dashboardData.supportData;

                if (supportData.recent_tickets) {
                    supportData.recent_tickets.slice(0, 2).forEach(ticket => {
                        const ticketId = `ticket-${ticket.id}`;
                        if (!existingIds.has(ticketId)) {
                            const ticketCreated = new Date(ticket.created_at);
                            const hourAgo = new Date(Date.now() - 3600000);

                            if (ticketCreated > hourAgo) {
                                enhancedNotifications.push({
                                    id: ticketId,
                                    type: 'support_ticket',
                                    notification_type: 'NEW_TICKET',
                                    title: `New Support Ticket #${ticket.ticket_number}`,
                                    message: `${ticket.user_name} created a ${ticket.priority} priority ticket`,
                                    is_urgent: ticket.priority === 'urgent',
                                    is_read: false,
                                    created_at: ticket.created_at,
                                    action_url: `/admin/support/tickets/${ticket.id}`
                                });
                                existingIds.add(ticketId);
                            }
                        }
                    });
                }
            }

            enhancedNotifications.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            return enhancedNotifications.slice(0, 20);

        } catch (error) {
            console.error('Error enhancing notifications:', error);
            return baseNotifications;
        }
    }

    updateSystemHealthCardsNew(data) {
        if (data.database) {
            this.updateHealthCardNew('database', {
                status: data.database.status === 'online' ? 'healthy' :
                    data.database.status === 'degraded' ? 'warning' : 'danger',
                connection: data.database.status,
                response_time: data.database.response,
                connections: data.database.connections
            });
        }

        if (data.cache) {
            this.updateHealthCardNew('cache', {
                status: data.cache.type !== 'unknown' && data.cache.hit_rate !== '0%' ? 'healthy' :
                    data.cache.type !== 'unknown' ? 'warning' : 'danger',
                type: data.cache.type,
                hit_rate: data.cache.hit_rate,
                memory: data.cache.memory
            });
        }

        if (data.external_apis) {
            const apis = data.external_apis;
            const allConfigured = apis.tmdb && apis.youtube && apis.cloudinary;
            const someConfigured = apis.tmdb || apis.youtube || apis.cloudinary;

            this.updateHealthCardNew('services', {
                status: allConfigured ? 'healthy' : someConfigured ? 'warning' : 'danger',
                tmdb: apis.tmdb,
                youtube: apis.youtube,
                cloudinary: apis.cloudinary
            });
        }

        if (data.performance) {
            const perf = data.performance;
            const cpuNum = parseInt(perf.cpu?.replace('%', '') || 0);
            const memNum = parseInt(perf.memory?.replace('%', '') || 0);
            const diskNum = parseInt(perf.disk?.replace('%', '') || 0);
            const maxUsage = Math.max(cpuNum, memNum, diskNum);

            this.updateHealthCardNew('performance', {
                status: maxUsage > 90 ? 'danger' : (maxUsage > 70 ? 'warning' : 'healthy'),
                cpu: perf.cpu,
                memory: perf.memory,
                disk: perf.disk
            });

            if (this.dashboard.statisticsManager && this.dashboard.statisticsManager.updatePerformanceChartNew) {
                this.dashboard.statisticsManager.updatePerformanceChartNew({
                    performance: perf
                });
            }
        }
    }

    updateHealthCardNew(type, data) {
        const healthStatus = document.getElementById(`${type}HealthStatus`);
        const healthDot = healthStatus?.querySelector('.health-dot');

        if (!healthDot) return;

        healthDot.className = `health-dot ${data.status === 'healthy' ? '' : data.status}`;

        if (type === 'database') {
            this.updateElement('dbConnectionStatus', data.connection || 'Unknown');
            this.updateElement('dbResponseTime', data.response_time || '--');
            this.updateElement('dbConnections', data.connections || '--');
        } else if (type === 'cache') {
            this.updateElement('cacheType', data.type || 'Unknown');
            this.updateElement('cacheHitRate', data.hit_rate || '--');
            this.updateElement('cacheMemory', data.memory || '--');
        } else if (type === 'services') {
            this.updateElement('tmdbStatus', data.tmdb ? '‚úì' : '‚úó');
            this.updateElement('youtubeStatus', data.youtube ? '‚úì' : '‚úó');
            this.updateElement('cloudinaryStatus', data.cloudinary ? '‚úì' : '‚úó');
        } else if (type === 'performance') {
            this.updateElement('cpuUsage', data.cpu || '--%');
            this.updateElement('memoryUsage', data.memory || '--%');
            this.updateElement('diskUsage', data.disk || '--%');
        }
    }

    updateSystemStatusBarNew(data) {
        const mainStatusDot = this.elements.mainStatusDot;
        const mainStatusText = this.elements.mainStatusText;

        if (data) {
            let overallStatus = 'healthy';

            if (data.database?.status !== 'online') {
                overallStatus = 'degraded';
            }

            if (data.performance) {
                const maxUsage = Math.max(
                    parseInt(data.performance.cpu?.replace('%', '') || 0),
                    parseInt(data.performance.memory?.replace('%', '') || 0),
                    parseInt(data.performance.disk?.replace('%', '') || 0)
                );

                if (maxUsage > 90) {
                    overallStatus = 'critical';
                } else if (maxUsage > 70 && overallStatus === 'healthy') {
                    overallStatus = 'degraded';
                }
            }

            if (data.cache?.type === 'unknown') {
                if (overallStatus === 'healthy') {
                    overallStatus = 'degraded';
                }
            }

            if (mainStatusDot) {
                mainStatusDot.className = `status-dot ${overallStatus === 'healthy' ? 'pulse-green' :
                    overallStatus === 'degraded' ? 'pulse-yellow' : 'pulse-red'
                    }`;
            }

            if (mainStatusText) {
                mainStatusText.textContent =
                    overallStatus === 'healthy' ? 'System Online' :
                        overallStatus === 'degraded' ? 'System Degraded' : 'System Critical';
            }
        }

        this.updateElement('dbStatus', data?.database?.status === 'online' ? 'Connected' : 'Error');
        this.updateElement('cacheStatus', data?.cache?.type !== 'unknown' ? 'Active' : 'Inactive');
        this.updateElement('apiStatus', data?.external_apis?.tmdb ? 'Online' : 'Offline');
    }

    updateServicesDisplay(data) {
        const servicesGrid = this.elements.servicesStatusGrid;
        if (!servicesGrid) return;

        const services = [
            { name: 'Auth', status: data.auth === 'online', icon: 'üîê' },
            { name: 'Admin', status: data.admin === 'online', icon: 'üë§' },
            { name: 'Support', status: data.support === 'online', icon: 'üéß' },
            { name: 'Content', status: data.content === 'online', icon: 'üé¨' },
            { name: 'Analytics', status: data.analytics === 'online', icon: 'üìä' },
            { name: 'Cache', status: data.cache === 'online', icon: '‚ö°' }
        ];

        servicesGrid.innerHTML = services.map(service => `
            <div class="service-item">
                <div class="service-status ${service.status ? '' : 'danger'}"></div>
                <div class="service-name">${service.name}</div>
                <div class="service-info">${service.status ? 'Online' : 'Offline'}</div>
            </div>
        `).join('');
    }

    updateAdminActivityMetrics(data) {
        const adminActivityMetrics = this.elements.adminActivityMetrics;
        if (!adminActivityMetrics) return;

        const metrics = [
            {
                label: 'Currently Active',
                value: data.active || 0,
                change: 'Right now'
            },
            {
                label: 'Active Admins',
                value: data.active_admins || 0,
                change: 'Last hour'
            },
            {
                label: 'Total Admins',
                value: data.total_admins || 0,
                change: 'System wide'
            },
            {
                label: 'Activity Rate',
                value: data.activity_rate || '0%',
                change: '24h average'
            }
        ];

        adminActivityMetrics.innerHTML = metrics.map(metric => `
            <div class="activity-metric">
                <div class="activity-metric-value">${metric.value}</div>
                <div class="activity-metric-label">${metric.label}</div>
                <div class="activity-metric-change">${metric.change}</div>
            </div>
        `).join('');

        const activityStatus = this.elements.adminActivityStatus;
        if (activityStatus) {
            const activityDot = activityStatus.querySelector('.activity-dot');
            const activityText = activityStatus.querySelector('.activity-text');

            if (activityDot && activityText) {
                if (data.active > 0) {
                    activityDot.className = 'activity-dot pulse-green';
                    activityText.textContent = 'Active';
                } else {
                    activityDot.className = 'activity-dot pulse-yellow';
                    activityText.textContent = 'Idle';
                }
            }
        }

        if (data.recommendations !== undefined) {
            const recommendationsBadge = document.getElementById('activeRecommendationsBadge');
            if (recommendationsBadge) {
                recommendationsBadge.textContent = data.recommendations;
                recommendationsBadge.style.display = data.recommendations > 0 ? 'inline-block' : 'none';
            }
        }
    }

    updateSystemAlertsNew(alerts) {
        const alertsSection = this.elements.alertsSection;
        const realTimeAlerts = this.elements.realTimeAlerts;
        const activeAlertsCount = this.elements.activeAlertsCount;

        if (!alerts || alerts.length === 0) {
            if (alertsSection) alertsSection.style.display = 'none';
            if (activeAlertsCount) activeAlertsCount.textContent = '0';
            return;
        }

        if (alertsSection) alertsSection.style.display = 'block';
        if (activeAlertsCount) activeAlertsCount.textContent = alerts.length;

        if (realTimeAlerts) {
            realTimeAlerts.innerHTML = alerts.map(alert => {
                const alertLevel = alert.type === 'urgent_ticket' ? 'urgent' :
                    alert.type === 'critical_issue' ? 'danger' :
                        alert.type === 'business_inquiry' ? 'info' : 'warning';

                return `
                    <div class="alert-item ${alertLevel}" data-alert-id="${alert.id || Date.now()}">
                        <div class="alert-icon">
                            <i data-feather="${this.getAlertIcon(alertLevel)}"></i>
                        </div>
                        <div class="alert-content">
                            <div class="alert-title">${alert.type?.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'System Alert'}</div>
                            <div class="alert-message">${alert.message}</div>
                            ${alert.url ? `<a href="${alert.url}" class="alert-link">View Details ‚Üí</a>` : ''}
                        </div>
                        <div class="alert-time">${this.dashboard.formatTimeAgo(alert.created_at || new Date().toISOString())}</div>
                        <div class="alert-actions">
                            <button class="alert-dismiss" onclick="adminDashboard.systemMonitor.dismissAlert('${alert.id || Date.now()}')">
                                <i data-feather="x"></i>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');

            if (typeof feather !== 'undefined') {
                feather.replace();
            }
        }
    }

    updateSystemNotificationsNew(data) {
        const notificationsList = this.elements.systemNotificationsList;
        if (!notificationsList) return;

        const notifications = data.notifications || data.recent_notifications || [];

        if (notifications.length === 0) {
            notificationsList.innerHTML = `
                <div class="table-empty-state">
                    <i data-feather="bell"></i>
                    <p>No system notifications</p>
                </div>
            `;
            if (typeof feather !== 'undefined') {
                feather.replace();
            }
            return;
        }

        notificationsList.innerHTML = notifications.slice(0, 5).map(notification => `
            <div class="notification-item ${notification.is_read ? '' : 'unread'} ${notification.is_urgent ? 'urgent' : ''}">
                <div class="notification-icon">
                    <i data-feather="${this.getNotificationIcon(notification.type || notification.notification_type)}"></i>
                </div>
                <div class="notification-content">
                    <div class="notification-title">${notification.title}</div>
                    <div class="notification-message">${this.dashboard.truncateText(notification.message, 60)}</div>
                    <div class="notification-time">${this.dashboard.formatTimeAgo(notification.created_at)}</div>
                </div>
            </div>
        `).join('');

        if (typeof feather !== 'undefined') {
            feather.replace();
        }
    }

    updateNotificationDropdown(notifications) {
        const dropdownContent = this.elements.notificationDropdownContent;
        if (!dropdownContent) return;

        try {
            if (!notifications || notifications.length === 0) {
                dropdownContent.innerHTML = `
                    <div class="notification-empty">
                        <i data-feather="bell-off"></i>
                        <p>No notifications</p>
                    </div>
                `;
                if (typeof feather !== 'undefined') {
                    feather.replace();
                }
                this.updateNotificationHeader(0);
                return;
            }

            const groupedNotifications = this.groupNotificationsByDate(notifications.slice(0, 15));

            let html = '';

            Object.entries(groupedNotifications).forEach(([date, notifs]) => {
                if (Object.keys(groupedNotifications).length > 1) {
                    html += `<div class="notification-date-header">${date}</div>`;
                }

                notifs.forEach(notification => {
                    const notifType = notification.type || notification.notification_type || 'info';
                    const isUrgent = notification.is_urgent || notification.action_required;
                    const notifLevel = isUrgent ? 'critical' :
                        notifType.includes('error') ? 'error' :
                            notifType.includes('warning') ? 'warning' :
                                notifType.includes('success') ? 'success' : 'info';

                    const actionUrl = (notification.action_url && notification.action_url !== 'undefined') ? notification.action_url : '';

                    html += `
                        <div class="notification-dropdown-item ${notification.is_read ? '' : 'unread'} ${notifLevel}" 
                             data-notification-id="${notification.id || ''}"
                             onclick="window.adminDashboard.systemMonitor.handleNotificationClick('${notification.id || ''}', '${actionUrl}')">
                            <div class="notification-dropdown-icon">
                                <i data-feather="${this.getNotificationIcon(notifType)}"></i>
                            </div>
                            <div class="notification-dropdown-body">
                                <div class="notification-dropdown-item-title">${notification.title}</div>
                                <div class="notification-dropdown-item-message">${this.dashboard.truncateText(notification.message, 60)}</div>
                                <div class="notification-dropdown-item-time">${this.formatRelativeTime(notification.created_at)}</div>
                            </div>
                        </div>
                    `;
                });
            });

            dropdownContent.innerHTML = html;

            if (typeof feather !== 'undefined') {
                feather.replace();
            }

            const unreadCount = notifications.filter(n => !n.is_read).length;
            this.updateNotificationHeader(unreadCount);

            console.log(`‚úÖ Updated dropdown with ${notifications.length} notifications (${unreadCount} unread)`);

        } catch (error) {
            console.error('Error updating notification dropdown:', error);
            this.showNotificationError();
        }
    }

    showNotificationError() {
        const dropdownContent = this.elements.notificationDropdownContent;
        if (dropdownContent) {
            dropdownContent.innerHTML = `
                <div class="notification-error">
                    <i data-feather="alert-triangle"></i>
                    <p>Failed to load notifications</p>
                    <button class="btn-text" onclick="window.adminDashboard.systemMonitor.retryLoadNotifications()">
                        <i data-feather="refresh-cw"></i>
                        Retry
                    </button>
                </div>
            `;
            if (typeof feather !== 'undefined') {
                feather.replace();
            }
        }
    }

    async retryLoadNotifications() {
        const dropdownContent = this.elements.notificationDropdownContent;
        if (dropdownContent) {
            dropdownContent.innerHTML = `
                <div class="notification-loading">
                    Loading notifications...
                </div>
            `;
        }

        this.isUpdatingNotifications = false;
        await this.loadAdminNotifications();
    }

    groupNotificationsByDate(notifications) {
        const groups = {};
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);

        notifications.forEach(notif => {
            const notifDate = new Date(notif.created_at);
            let dateKey;

            if (notifDate.toDateString() === today.toDateString()) {
                dateKey = 'Today';
            } else if (notifDate.toDateString() === yesterday.toDateString()) {
                dateKey = 'Yesterday';
            } else {
                dateKey = notifDate.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric'
                });
            }

            if (!groups[dateKey]) {
                groups[dateKey] = [];
            }
            groups[dateKey].push(notif);
        });

        return groups;
    }

    updateNotificationHeader(unreadCount) {
        const title = document.querySelector('.notification-dropdown-title');
        if (title) {
            const titleText = title.querySelector('span') || title;
            if (unreadCount > 0) {
                titleText.textContent = `Notifications (${unreadCount})`;
            } else {
                titleText.textContent = 'Notifications';
            }
        }
    }

    async handleNotificationClick(notificationId, actionUrl) {
        if (!notificationId) {
            if (actionUrl && actionUrl !== '' && actionUrl !== 'undefined') {
                window.location.href = actionUrl;
            }
            this.hideNotificationDropdown();
            return;
        }

        try {
            const notificationElement = document.querySelector(`[data-notification-id="${notificationId}"]`);
            if (notificationElement) {
                notificationElement.classList.remove('unread');
            }

            await this.markNotificationAsRead(notificationId);

            if (actionUrl && actionUrl !== '' && actionUrl !== 'undefined') {
                setTimeout(() => {
                    window.location.href = actionUrl;
                }, 100);
            } else {
                this.hideNotificationDropdown();
            }
        } catch (error) {
            console.error('Error handling notification click:', error);
            this.hideNotificationDropdown();
        }
    }

    async markNotificationAsRead(notificationId) {
        try {
            const response = await this.dashboard.makeAuthenticatedRequest(`/admin/notifications/${notificationId}/read`, {
                method: 'PUT'
            });

            if (response.ok) {
                const notifications = JSON.parse(localStorage.getItem('cinebrain-admin-notifications') || '[]');
                const notifIndex = notifications.findIndex(n => n.id === notificationId);
                if (notifIndex !== -1) {
                    notifications[notifIndex].is_read = true;
                    localStorage.setItem('cinebrain-admin-notifications', JSON.stringify(notifications));
                }

                setTimeout(() => {
                    this.loadAdminNotifications();
                }, 500);

                return true;
            } else {
                throw new Error(`Failed to mark notification as read: ${response.status}`);
            }
        } catch (error) {
            console.error('Error marking notification as read:', error);
            return false;
        }
    }

    formatRelativeTime(dateString) {
        const now = new Date();
        const date = new Date(dateString);
        const diffInSeconds = Math.floor((now - date) / 1000);

        if (diffInSeconds < 60) return 'Just now';
        if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
        if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
        if (diffInSeconds < 604800) return `${Math.floor(diffInSeconds / 86400)}d ago`;

        return date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
        });
    }

    updateSystemHealth(data) {
        if (!data) return;

        const status = data.status || 'unknown';

        const performanceIndicator = this.elements.performanceIndicator;
        if (performanceIndicator) {
            const performanceDot = performanceIndicator.querySelector('.performance-dot');
            const performanceText = performanceIndicator.querySelector('.performance-text');

            if (performanceDot && performanceText) {
                if (status === 'healthy') {
                    performanceDot.className = 'performance-dot';
                    performanceText.textContent = 'Optimal';
                } else if (status === 'degraded') {
                    performanceDot.className = 'performance-dot warning';
                    performanceText.textContent = 'Warning';
                } else {
                    performanceDot.className = 'performance-dot danger';
                    performanceText.textContent = 'Critical';
                }
            }
        }

        if (data.configuration) {
            console.log('System Configuration:', data.configuration);
        }

        if (data.components) {
            const criticalComponents = ['database', 'cache', 'support_system'];
            criticalComponents.forEach(component => {
                if (data.components[component]?.status === 'unhealthy' ||
                    data.components[component]?.status === 'error') {
                    this.handleNewAlert({
                        type: 'system_health',
                        level: 'critical',
                        message: `${component.replace('_', ' ').toUpperCase()} is experiencing issues`,
                        created_at: new Date().toISOString()
                    });
                }
            });
        }
    }

    updateLiveConnectionStatus() {
        if (this.elements.liveConnectionStatus) {
            this.elements.liveConnectionStatus.textContent = 'LIVE';
            this.elements.liveConnectionStatus.style.color = 'var(--admin-success)';
        }

        if (this.elements.lastUpdate) {
            const now = new Date();
            const timeString = this.dashboard.isMobile ?
                now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) :
                now.toLocaleTimeString();
            this.elements.lastUpdate.textContent = timeString;
        }
    }

    handleNewAlert(alert) {
        this.notificationQueue.push({
            type: 'alert',
            title: alert.type?.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()) || 'System Alert',
            message: alert.message,
            level: alert.level || 'warning',
            timestamp: alert.created_at || alert.timestamp || new Date().toISOString(),
            data: alert
        });
    }

    handleNewNotification(notification) {
        const notifId = notification.id || `${notification.type}-${notification.created_at}`;

        if (!this.processedNotifications.has(notifId)) {
            this.notificationQueue.push({
                type: 'notification',
                title: notification.title,
                message: notification.message,
                level: notification.is_urgent ? 'warning' : 'info',
                timestamp: notification.created_at || new Date().toISOString(),
                data: notification
            });
        }
    }

    processNotificationQueue() {
        if (this.notificationQueue.length > 0) {
            const notification = this.notificationQueue.shift();
            this.sendNotificationToTopbar(notification);
        }
    }

    sendNotificationToTopbar(notification) {
        const notificationBell = document.getElementById('notificationBell');
        if (notificationBell) {
            notificationBell.classList.add('notification-pulse');
            setTimeout(() => {
                notificationBell.classList.remove('notification-pulse');
            }, 1000);
        }

        const notifications = JSON.parse(localStorage.getItem('cinebrain-admin-notifications') || '[]');
        notifications.unshift({
            id: Date.now(),
            ...notification,
            isRead: false,
            createdAt: new Date().toISOString()
        });

        if (notifications.length > 50) {
            notifications.splice(50);
        }

        localStorage.setItem('cinebrain-admin-notifications', JSON.stringify(notifications));

        if (this.isNotificationDropdownOpen()) {
            this.updateNotificationDropdown(notifications);
        }

        setTimeout(() => {
            window.dispatchEvent(new CustomEvent('cinebrain-notification', {
                detail: notification,
                bubbles: true
            }));
        }, 100);

        if (notification.level === 'critical' || notification.level === 'error' || notification.level === 'urgent') {
            this.dashboard.showToast(notification.message, notification.level === 'critical' ? 'error' : 'warning');
        }
    }

    toggleNotificationDropdown() {
        const dropdown = this.elements.notificationDropdown;
        if (!dropdown) return;

        const isOpen = this.isNotificationDropdownOpen();

        if (isOpen) {
            this.hideNotificationDropdown();
        } else {
            this.showNotificationDropdown();
        }
    }

    isNotificationDropdownOpen() {
        const dropdown = this.elements.notificationDropdown;
        return dropdown && dropdown.classList.contains('show');
    }

    showNotificationDropdown() {
        const dropdown = this.elements.notificationDropdown;
        if (!dropdown) return;

        const dropdownContent = this.elements.notificationDropdownContent;
        if (dropdownContent) {
            dropdownContent.innerHTML = `
                <div class="notification-loading">
                    Loading notifications...
                </div>
            `;
        }

        dropdown.style.display = 'flex';
        setTimeout(() => {
            dropdown.classList.add('show');
        }, 10);

        const notificationBell = document.getElementById('notificationBell');
        if (notificationBell) {
            notificationBell.classList.add('active');
        }

        setTimeout(() => {
            this.loadAdminNotifications();
        }, 100);
    }

    hideNotificationDropdown() {
        const dropdown = this.elements.notificationDropdown;
        if (!dropdown) return;

        dropdown.classList.remove('show');

        setTimeout(() => {
            dropdown.style.display = 'none';
        }, 300);

        const notificationBell = document.getElementById('notificationBell');
        if (notificationBell) {
            notificationBell.classList.remove('active');
        }
    }

    async performQuickHealthCheck() {
        this.dashboard.showToast('Running quick health check...', 'info');

        try {
            await Promise.all([
                this.loadSystemMonitoringData(),
                this.loadServiceStatusData(),
                this.loadSystemHealthData()
            ]);
            this.dashboard.showToast('Health check completed', 'success');
        } catch (error) {
            this.dashboard.showToast('Health check failed', 'error');
        }
    }

    updateMonitoringRefreshRate(newRate) {
        this.monitoring.refreshRate = newRate;
        this.stopSystemMonitoringNew();
        this.startSystemMonitoringNew();
        this.dashboard.showToast(`Monitoring refresh rate updated to ${newRate / 1000}s`, 'success');
    }

    checkMissedNotifications() {
        this.loadAdminNotifications();
        this.loadSupportAlerts();
    }

    dismissAlert(alertId) {
        const alertElement = document.querySelector(`[data-alert-id="${alertId}"]`);
        if (alertElement) {
            alertElement.style.animation = 'fadeOutRight 0.3s ease';
            setTimeout(() => {
                alertElement.remove();
            }, 300);
        }

        this.systemData.alerts = this.systemData.alerts.filter(alert =>
            (alert.id || Date.now().toString()) !== alertId
        );

        const activeAlertsCount = this.elements.activeAlertsCount;
        if (activeAlertsCount) {
            activeAlertsCount.textContent = this.systemData.alerts.length;
        }

        if (this.systemData.alerts.length === 0) {
            const alertsSection = this.elements.alertsSection;
            if (alertsSection) {
                alertsSection.style.display = 'none';
            }
        }
    }

    dismissAllAlerts() {
        const alertsContainer = this.elements.realTimeAlerts;
        const alertsSection = this.elements.alertsSection;

        if (alertsContainer) {
            alertsContainer.innerHTML = '';
        }
        if (alertsSection) {
            alertsSection.style.display = 'none';
        }

        this.systemData.alerts = [];
        this.processedAlerts.clear();

        const activeAlertsCount = this.elements.activeAlertsCount;
        if (activeAlertsCount) {
            activeAlertsCount.textContent = '0';
        }

        this.dashboard.showToast('All alerts dismissed', 'success');
    }

    async markAllNotificationsAsRead() {
        try {
            const response = await this.dashboard.makeAuthenticatedRequest('/admin/notifications/mark-all-read', {
                method: 'PUT'
            });

            if (response.ok) {
                const data = await response.json();

                document.querySelectorAll('.notification-dropdown-item.unread').forEach(item => {
                    item.classList.remove('unread');
                });

                const notifications = JSON.parse(localStorage.getItem('cinebrain-admin-notifications') || '[]');
                notifications.forEach(n => n.is_read = true);
                localStorage.setItem('cinebrain-admin-notifications', JSON.stringify(notifications));

                this.updateNotificationHeader(0);

                setTimeout(() => {
                    this.loadAdminNotifications();
                }, 500);

                this.dashboard.showToast(data.message || 'All notifications marked as read', 'success');
                return true;
            } else {
                throw new Error('Failed to mark notifications as read');
            }
        } catch (error) {
            console.error('Error marking all notifications as read:', error);
            this.dashboard.showToast('Failed to mark notifications as read', 'error');
            return false;
        }
    }

    stopSystemMonitoringNew() {
        if (this.monitoring.systemTimer) {
            clearInterval(this.monitoring.systemTimer);
            this.monitoring.systemTimer = null;
        }
        if (this.monitoring.serviceTimer) {
            clearInterval(this.monitoring.serviceTimer);
            this.monitoring.serviceTimer = null;
        }
        if (this.monitoring.alertsTimer) {
            clearInterval(this.monitoring.alertsTimer);
            this.monitoring.alertsTimer = null;
        }
        if (this.monitoring.healthTimer) {
            clearInterval(this.monitoring.healthTimer);
            this.monitoring.healthTimer = null;
        }
        if (this.monitoring.notificationTimer) {
            clearInterval(this.monitoring.notificationTimer);
            this.monitoring.notificationTimer = null;
        }
        if (this.monitoring.activityTimer) {
            clearInterval(this.monitoring.activityTimer);
            this.monitoring.activityTimer = null;
        }

        console.log('‚èπ System monitoring stopped');
    }

    getAlertIcon(level) {
        const icons = {
            'critical': 'alert-octagon',
            'danger': 'alert-circle',
            'error': 'x-circle',
            'warning': 'alert-triangle',
            'urgent': 'zap',
            'info': 'info',
            'success': 'check-circle'
        };
        return icons[level] || 'alert-circle';
    }

    getNotificationIcon(type) {
        const icons = {
            'NEW_TICKET': 'message-circle',
            'new_ticket': 'message-circle',
            'support_ticket': 'message-circle',
            'URGENT_TICKET': 'alert-circle',
            'urgent_ticket': 'alert-circle',
            'CONTACT_RECEIVED': 'mail',
            'contact_message': 'mail',
            'ISSUE_REPORTED': 'alert-triangle',
            'issue_report': 'alert-triangle',
            'rise_issue': 'trending-up',
            'TICKET_ESCALATION': 'trending-up',
            'ticket_escalation': 'trending-up',
            'SLA_BREACH': 'clock',
            'sla_breach': 'clock',
            'FEEDBACK_RECEIVED': 'message-square',
            'feedback_received': 'message-square',
            'SYSTEM_ALERT': 'alert-triangle',
            'system_alert': 'alert-triangle',
            'USER_ACTIVITY': 'users',
            'user_activity': 'user-plus',
            'USER_REGISTERED': 'user-plus',
            'CONTENT_ADDED': 'plus-circle',
            'content_added': 'film',
            'content_activity': 'film',
            'RECOMMENDATION_CREATED': 'star',
            'admin_recommendation': 'star',
            'recommendation_created': 'star',
            'recommendation_published': 'send',
            'cache_operation': 'zap',
            'bulk_operation': 'layers',
            'slug_update': 'edit'
        };
        return icons[type] || 'bell';
    }

    updateElement(id, value) {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = value;
        }
    }

    destroy() {
        this.stopSystemMonitoringNew();

        if (this.notificationUpdateDebounce) {
            clearTimeout(this.notificationUpdateDebounce);
        }

        this.notificationQueue = [];
        this.processedAlerts.clear();
        this.processedNotifications.clear();
        console.log('üóë System monitor v3.0 destroyed');
    }
}

window.SystemMonitor = SystemMonitor;


4. emailPreferences.js
// admin/emailpreferences.js

class EmailPreferences {
    constructor() {
        this.apiBase = window.CineBrainConfig.apiBase;
        this.preferences = null;
        this.isLoading = false;
        this.isMobile = window.innerWidth <= 768;

        this.init();
    }

    async init() {
        try {
            // Check if admin is authenticated
            if (!await this.checkAdminAuth()) {
                console.error('Not authenticated for email preferences');
                return;
            }

            this.setupEventListeners();
            await this.loadPreferences();
            this.renderPreferences();

        } catch (error) {
            console.error('Error initializing email preferences:', error);
            this.showError('Failed to initialize email preferences');
        }
    }

    async checkAdminAuth() {
        try {
            const token = localStorage.getItem('cinebrain-token');
            const userStr = localStorage.getItem('cinebrain-user');

            if (!token || !userStr) return false;

            const user = JSON.parse(userStr);
            return user.is_admin;

        } catch (error) {
            return false;
        }
    }

    setupEventListeners() {
        // Toggle email preferences section
        const toggleBtn = document.getElementById('toggleEmailPreferences');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', () => {
                this.togglePreferencesSection();
            });
        }

        // Save preferences button
        const saveBtn = document.getElementById('saveEmailPreferences');
        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                this.savePreferences();
            });
        }

        // Reset to defaults button
        const resetBtn = document.getElementById('resetEmailPreferences');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                this.resetToDefaults();
            });
        }

        // Quick toggle buttons
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('quick-toggle-btn')) {
                const category = e.target.dataset.category;
                const enabled = e.target.dataset.enabled === 'true';
                this.quickToggleCategory(category, !enabled);
            }
        });

        // Individual preference toggles
        document.addEventListener('change', (e) => {
            if (e.target.classList.contains('preference-toggle')) {
                this.handlePreferenceToggle(e.target);
            }
        });

        // Window resize handling
        window.addEventListener('resize', () => {
            const wasMobile = this.isMobile;
            this.isMobile = window.innerWidth <= 768;

            if (wasMobile !== this.isMobile) {
                this.renderPreferences();
            }
        });
    }

    async loadPreferences() {
        this.isLoading = true;
        this.showLoading(true);

        try {
            const response = await this.makeAuthenticatedRequest('/admin/email-preferences');

            if (response.ok) {
                const data = await response.json();
                this.preferences = data.preferences;
                this.lastUpdated = data.updated_at;

                console.log('‚úÖ Email preferences loaded');
            } else {
                throw new Error(`Failed to load preferences: ${response.status}`);
            }

        } catch (error) {
            console.error('Error loading email preferences:', error);
            this.showError('Failed to load email preferences');

            // Set default preferences
            this.preferences = this.getDefaultPreferences();

        } finally {
            this.isLoading = false;
            this.showLoading(false);
        }
    }

    getDefaultPreferences() {
        return {
            critical_alerts: {
                urgent_tickets: true,
                sla_breaches: true,
                system_alerts: true
            },
            content_management: {
                content_added: true,
                recommendation_created: true,
                recommendation_updated: false,
                recommendation_deleted: false,
                recommendation_published: true
            },
            user_activity: {
                user_feedback: true,
                regular_tickets: false
            },
            system_operations: {
                cache_operations: false,
                bulk_operations: false,
                slug_updates: false
            }
        };
    }

    renderPreferences() {
        const container = document.getElementById('emailPreferencesContent');
        if (!container || !this.preferences) return;

        const categories = this.getPreferenceCategories();

        container.innerHTML = `
            <div class="email-preferences-container">
                <div class="preferences-header">
                    <div class="preferences-title">
                        <h4>
                            <i data-feather="mail"></i>
                            Email Alert Preferences
                        </h4>
                        <p class="preferences-subtitle">
                            Control which email notifications you receive. Critical alerts are always recommended.
                        </p>
                    </div>
                    <div class="preferences-actions">
                        <button class="btn btn-outline-secondary btn-sm" id="resetEmailPreferences">
                            <i data-feather="refresh-cw"></i>
                            <span class="d-none d-sm-inline">Reset Defaults</span>
                        </button>
                        <button class="btn btn-primary btn-sm" id="saveEmailPreferences">
                            <i data-feather="save"></i>
                            <span class="d-none d-sm-inline">Save Changes</span>
                        </button>
                    </div>
                </div>

                <div class="preferences-grid">
                    ${categories.map(category => this.renderCategory(category)).join('')}
                </div>

                <div class="preferences-footer">
                    <div class="preferences-info">
                        <i data-feather="info"></i>
                        <span>Last updated: ${this.lastUpdated ? new Date(this.lastUpdated).toLocaleString() : 'Never'}</span>
                    </div>
                    <div class="preferences-status" id="preferencesStatus"></div>
                </div>
            </div>
        `;

        // Re-attach event listeners for new elements
        this.attachCategoryEventListeners();

        if (typeof feather !== 'undefined') {
            feather.replace();
        }
    }

    getPreferenceCategories() {
        return [
            {
                id: 'critical_alerts',
                title: 'üö® Critical Alerts',
                description: 'Important system alerts that require immediate attention',
                icon: 'alert-circle',
                color: '#ef4444',
                recommended: true,
                items: [
                    {
                        key: 'urgent_tickets',
                        label: 'Urgent Support Tickets',
                        description: 'Get notified when urgent support tickets are created',
                        recommended: true
                    },
                    {
                        key: 'sla_breaches',
                        label: 'SLA Breaches',
                        description: 'Alerts when support tickets exceed SLA deadlines',
                        recommended: true
                    },
                    {
                        key: 'system_alerts',
                        label: 'System Alerts',
                        description: 'Critical system errors and downtime notifications',
                        recommended: true
                    }
                ]
            },
            {
                id: 'content_management',
                title: 'üé¨ Content Management',
                description: 'Notifications about content and recommendation activities',
                icon: 'film',
                color: '#113CCF',
                recommended: false,
                items: [
                    {
                        key: 'content_added',
                        label: 'Content Added',
                        description: 'New movies, shows, or anime added to the platform'
                    },
                    {
                        key: 'recommendation_created',
                        label: 'Recommendation Created',
                        description: 'When new admin recommendations are created'
                    },
                    {
                        key: 'recommendation_updated',
                        label: 'Recommendation Updated',
                        description: 'When recommendations are modified'
                    },
                    {
                        key: 'recommendation_deleted',
                        label: 'Recommendation Deleted',
                        description: 'When recommendations are removed'
                    },
                    {
                        key: 'recommendation_published',
                        label: 'Recommendation Published',
                        description: 'When recommendations go live'
                    }
                ]
            },
            {
                id: 'user_activity',
                title: 'üë• User Activity',
                description: 'Notifications about user interactions and feedback',
                icon: 'users',
                color: '#10b981',
                recommended: false,
                items: [
                    {
                        key: 'user_feedback',
                        label: 'User Feedback',
                        description: 'New user feedback and reviews submitted'
                    },
                    {
                        key: 'regular_tickets',
                        label: 'Regular Support Tickets',
                        description: 'Non-urgent support tickets (can be noisy)'
                    }
                ]
            },
            {
                id: 'system_operations',
                title: '‚öôÔ∏è System Operations',
                description: 'Technical operations and maintenance activities',
                icon: 'settings',
                color: '#8b5cf6',
                recommended: false,
                items: [
                    {
                        key: 'cache_operations',
                        label: 'Cache Operations',
                        description: 'Cache clearing and maintenance operations'
                    },
                    {
                        key: 'bulk_operations',
                        label: 'Bulk Operations',
                        description: 'Bulk content updates and migrations'
                    },
                    {
                        key: 'slug_updates',
                        label: 'Slug Updates',
                        description: 'Content URL slug modifications'
                    }
                ]
            }
        ];
    }

    renderCategory(category) {
        const categoryPrefs = this.preferences[category.id];
        const enabledCount = Object.values(categoryPrefs).filter(Boolean).length;
        const totalCount = Object.keys(categoryPrefs).length;

        return `
            <div class="preference-category" data-category="${category.id}">
                <div class="category-header">
                    <div class="category-info">
                        <div class="category-title">
                            <i data-feather="${category.icon}" style="color: ${category.color}"></i>
                            <span>${category.title}</span>
                            ${category.recommended ? '<span class="category-badge recommended">Recommended</span>' : ''}
                        </div>
                        <p class="category-description">${category.description}</p>
                        <div class="category-stats">
                            <span class="enabled-count">${enabledCount}/${totalCount} enabled</span>
                        </div>
                    </div>
                    <div class="category-actions">
                        <button class="quick-toggle-btn ${enabledCount === totalCount ? 'btn-danger' : 'btn-success'}" 
                                data-category="${category.id}" 
                                data-enabled="${enabledCount === totalCount}"
                                title="${enabledCount === totalCount ? 'Disable All' : 'Enable All'}">
                            <i data-feather="${enabledCount === totalCount ? 'toggle-right' : 'toggle-left'}"></i>
                            <span class="d-none d-md-inline">${enabledCount === totalCount ? 'Disable All' : 'Enable All'}</span>
                        </button>
                    </div>
                </div>
                
                <div class="category-items">
                    ${category.items.map(item => this.renderPreferenceItem(item, categoryPrefs[item.key], category.id)).join('')}
                </div>
            </div>
        `;
    }

    renderPreferenceItem(item, enabled, categoryId) {
        const switchId = `${categoryId}_${item.key}`;

        return `
            <div class="preference-item">
                <div class="preference-info">
                    <div class="preference-label">
                        <label for="${switchId}" class="form-label">
                            ${item.label}
                            ${item.recommended ? '<span class="item-badge recommended">Recommended</span>' : ''}
                        </label>
                    </div>
                    <p class="preference-description">${item.description}</p>
                </div>
                <div class="preference-control">
                    <div class="form-check form-switch">
                        <input class="form-check-input preference-toggle" 
                               type="checkbox" 
                               id="${switchId}"
                               data-category="${categoryId}"
                               data-key="${item.key}"
                               ${enabled ? 'checked' : ''}>
                        <label class="form-check-label" for="${switchId}">
                            <span class="toggle-text">${enabled ? 'On' : 'Off'}</span>
                        </label>
                    </div>
                </div>
            </div>
        `;
    }

    attachCategoryEventListeners() {
        // Re-attach save button listener
        const saveBtn = document.getElementById('saveEmailPreferences');
        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                this.savePreferences();
            });
        }

        // Re-attach reset button listener
        const resetBtn = document.getElementById('resetEmailPreferences');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                this.resetToDefaults();
            });
        }
    }

    togglePreferencesSection() {
        const section = document.getElementById('emailPreferencesSection');
        const toggleBtn = document.getElementById('toggleEmailPreferences');
        const icon = toggleBtn?.querySelector('i');

        if (section) {
            const isHidden = section.style.display === 'none';

            if (isHidden) {
                section.style.display = 'block';
                if (icon) icon.setAttribute('data-feather', 'chevron-up');

                // Load preferences if not already loaded
                if (!this.preferences) {
                    this.loadPreferences().then(() => {
                        this.renderPreferences();
                    });
                }
            } else {
                section.style.display = 'none';
                if (icon) icon.setAttribute('data-feather', 'chevron-down');
            }

            if (typeof feather !== 'undefined') {
                feather.replace();
            }
        }
    }

    handlePreferenceToggle(toggle) {
        const category = toggle.dataset.category;
        const key = toggle.dataset.key;
        const enabled = toggle.checked;

        // Update preferences object
        if (this.preferences[category]) {
            this.preferences[category][key] = enabled;
        }

        // Update toggle text
        const label = toggle.nextElementSibling;
        const toggleText = label?.querySelector('.toggle-text');
        if (toggleText) {
            toggleText.textContent = enabled ? 'On' : 'Off';
        }

        // Update category stats
        this.updateCategoryStats(category);

        // Show unsaved changes indicator
        this.showUnsavedChanges(true);
    }

    quickToggleCategory(categoryId, enable) {
        if (!this.preferences[categoryId]) return;

        // Update all preferences in category
        Object.keys(this.preferences[categoryId]).forEach(key => {
            this.preferences[categoryId][key] = enable;

            // Update UI toggles
            const toggle = document.querySelector(`[data-category="${categoryId}"][data-key="${key}"]`);
            if (toggle) {
                toggle.checked = enable;

                const label = toggle.nextElementSibling;
                const toggleText = label?.querySelector('.toggle-text');
                if (toggleText) {
                    toggleText.textContent = enable ? 'On' : 'Off';
                }
            }
        });

        // Update category quick toggle button
        this.updateCategoryQuickToggle(categoryId);
        this.updateCategoryStats(categoryId);
        this.showUnsavedChanges(true);
    }

    updateCategoryStats(categoryId) {
        const categoryPrefs = this.preferences[categoryId];
        const enabledCount = Object.values(categoryPrefs).filter(Boolean).length;
        const totalCount = Object.keys(categoryPrefs).length;

        const statsElement = document.querySelector(`[data-category="${categoryId}"] .enabled-count`);
        if (statsElement) {
            statsElement.textContent = `${enabledCount}/${totalCount} enabled`;
        }

        this.updateCategoryQuickToggle(categoryId);
    }

    updateCategoryQuickToggle(categoryId) {
        const categoryPrefs = this.preferences[categoryId];
        const enabledCount = Object.values(categoryPrefs).filter(Boolean).length;
        const totalCount = Object.keys(categoryPrefs).length;
        const allEnabled = enabledCount === totalCount;

        const quickToggleBtn = document.querySelector(`[data-category="${categoryId}"].quick-toggle-btn`);
        if (quickToggleBtn) {
            quickToggleBtn.className = `quick-toggle-btn ${allEnabled ? 'btn-danger' : 'btn-success'}`;
            quickToggleBtn.dataset.enabled = allEnabled;
            quickToggleBtn.title = allEnabled ? 'Disable All' : 'Enable All';

            const icon = quickToggleBtn.querySelector('i');
            const text = quickToggleBtn.querySelector('span');

            if (icon) {
                icon.setAttribute('data-feather', allEnabled ? 'toggle-right' : 'toggle-left');
            }

            if (text) {
                text.textContent = allEnabled ? 'Disable All' : 'Enable All';
            }

            if (typeof feather !== 'undefined') {
                feather.replace();
            }
        }
    }

    async savePreferences() {
        if (this.isLoading || !this.preferences) return;

        this.isLoading = true;
        this.showSaveLoading(true);

        try {
            const response = await this.makeAuthenticatedRequest('/admin/email-preferences', {
                method: 'PUT',
                body: JSON.stringify({
                    preferences: this.preferences
                })
            });

            if (response.ok) {
                const data = await response.json();
                this.lastUpdated = data.updated_at;

                this.showSuccess('Email preferences saved successfully');
                this.showUnsavedChanges(false);

                // Update footer timestamp
                const infoElement = document.querySelector('.preferences-info span');
                if (infoElement) {
                    infoElement.textContent = `Last updated: ${new Date(this.lastUpdated).toLocaleString()}`;
                }

            } else {
                throw new Error(`Failed to save preferences: ${response.status}`);
            }

        } catch (error) {
            console.error('Error saving email preferences:', error);
            this.showError('Failed to save email preferences');

        } finally {
            this.isLoading = false;
            this.showSaveLoading(false);
        }
    }

    resetToDefaults() {
        if (confirm('Are you sure you want to reset all email preferences to default values?')) {
            this.preferences = this.getDefaultPreferences();
            this.renderPreferences();
            this.showUnsavedChanges(true);
            this.showSuccess('Preferences reset to defaults');
        }
    }

    showUnsavedChanges(show) {
        const statusElement = document.getElementById('preferencesStatus');
        if (statusElement) {
            if (show) {
                statusElement.innerHTML = '<i data-feather="alert-circle"></i> <span>Unsaved changes</span>';
                statusElement.className = 'preferences-status unsaved';
            } else {
                statusElement.innerHTML = '<i data-feather="check-circle"></i> <span>Saved</span>';
                statusElement.className = 'preferences-status saved';
            }

            if (typeof feather !== 'undefined') {
                feather.replace();
            }
        }
    }

    showLoading(show) {
        const container = document.getElementById('emailPreferencesContent');
        if (!container) return;

        if (show) {
            container.innerHTML = `
                <div class="preferences-loading">
                    <div class="loading-spinner"></div>
                    <p>Loading email preferences...</p>
                </div>
            `;
        }
    }

    showSaveLoading(show) {
        const saveBtn = document.getElementById('saveEmailPreferences');
        if (!saveBtn) return;

        if (show) {
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<i data-feather="loader" class="spinning"></i> <span class="d-none d-sm-inline">Saving...</span>';
        } else {
            saveBtn.disabled = false;
            saveBtn.innerHTML = '<i data-feather="save"></i> <span class="d-none d-sm-inline">Save Changes</span>';
        }

        if (typeof feather !== 'undefined') {
            feather.replace();
        }
    }

    async makeAuthenticatedRequest(endpoint, options = {}) {
        const token = localStorage.getItem('cinebrain-token');

        const defaultOptions = {
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            }
        };

        const mergedOptions = {
            ...defaultOptions,
            ...options,
            headers: {
                ...defaultOptions.headers,
                ...(options.headers || {})
            }
        };

        const response = await fetch(`${this.apiBase}${endpoint}`, mergedOptions);

        if (response.status === 401) {
            localStorage.removeItem('cinebrain-token');
            localStorage.removeItem('cinebrain-user');
            window.location.href = '/auth/login.html';
            throw new Error('Authentication failed');
        }

        return response;
    }

    showSuccess(message) {
        this.showToast(message, 'success');
    }

    showError(message) {
        this.showToast(message, 'error');
    }

    showToast(message, type = 'info') {
        // Use existing notification system from dashboard or create fallback
        if (window.adminDashboard && window.adminDashboard.showToast) {
            window.adminDashboard.showToast(message, type);
        } else {
            // Fallback toast
            console.log(`${type.toUpperCase()}: ${message}`);
        }
    }
}

// Initialize email preferences
let emailPreferences;

document.addEventListener('DOMContentLoaded', () => {
    // Initialize after a short delay to ensure dashboard is ready
    setTimeout(() => {
        emailPreferences = new EmailPreferences();
    }, 1000);
});

// Export for global access
window.EmailPreferences = EmailPreferences;
window.emailPreferences = emailPreferences;