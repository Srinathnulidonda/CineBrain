1. trending.html

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Trending - CineBrain</title>

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="/assets/images/favicon.png">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Bangers&family=Inter:wght@300;400;500;600;700;800;900&display=swap"
        rel="stylesheet">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/loader.css">
    <link rel="stylesheet" href="/css/topbar.css">
    <link rel="stylesheet" href="/css/mobile-nav.css">
    <link rel="stylesheet" href="/css/content-card.css">
    <link rel="stylesheet" href="/css/trending.css">
    <link rel="stylesheet" href="/css/theme.css">

    <!-- Apply theme immediately -->
    <script>
        (function () {
            const savedTheme = localStorage.getItem('cinebrain-theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            document.documentElement.setAttribute('data-bs-theme', savedTheme);
        })();
    </script>
</head>

<body>
    <!-- TopBar Navigation -->
    <nav class="navbar navbar-expand-lg navbar-cinebrain fixed-top">
        <div class="container-fluid">
            <!-- Brand Section -->
            <div class="navbar-brand-wrapper">
                <a href="/" style="text-decoration: none;">
                    <div class="navbar-brand-cinebrain">CineBrain</div>
                    <div class="tagline">
                        <span class="tagline-full">The Mind Behind Your Next Favorite</span>
                        <span class="tagline-medium" style="display: none;">Your Next Favorite</span>
                        <span class="tagline-short" style="display: none;">Next Favorite</span>
                    </div>
                </a>
            </div>

            <!-- Desktop Search -->
            <div class="search-container desktop-search" id="desktopSearchContainer">
                <div class="search-wrapper">
                    <div class="search-bar-wrapper">
                        <div class="search-input-wrapper">
                            <i data-feather="search" class="search-icon"></i>
                            <input type="text" class="form-control search-input" id="desktopSearchInput"
                                placeholder="Search movies, shows, anime..." autocomplete="off">
                            <button class="search-clear" id="searchClear" aria-label="Clear search"
                                style="display: none;">
                                <i data-feather="x"></i>
                            </button>
                        </div>
                        <div class="search-results" id="desktopSearchResults"></div>
                    </div>
                </div>
            </div>

            <!-- Right Section: Icons -->
            <div class="nav-icons-section">
                <button class="icon-button mobile-search-trigger" id="mobileSearchTrigger" aria-label="Search">
                    <i data-feather="search"></i>
                </button>
                <button class="icon-button theme-toggle" id="themeToggle" aria-label="Toggle theme">
                    <i data-feather="sun" class="theme-icon theme-icon-light"></i>
                    <i data-feather="moon" class="theme-icon theme-icon-dark"></i>
                </button>
                <div class="dropdown">
                    <div class="avatar-menu" data-bs-toggle="dropdown" aria-expanded="false" id="avatarMenu"
                        role="button">
                        <i data-feather="user"></i>
                    </div>
                    <ul class="dropdown-menu dropdown-menu-end dropdown-menu-cinebrain" id="userDropdown"></ul>
                </div>
            </div>
        </div>
    </nav>

    <!-- Mobile Search Overlay -->
    <div class="mobile-search-overlay" id="mobileSearchOverlay">
        <div class="container">
            <div class="mobile-search-header">
                <button class="btn-back" id="closeMobileSearch" aria-label="Close search">
                    <i data-feather="arrow-left"></i>
                </button>
                <div class="mobile-search-input-wrapper">
                    <i data-feather="search" class="search-icon"></i>
                    <input type="text" class="form-control search-input" id="mobileSearchInput"
                        placeholder="Search movies, shows, anime..." autocomplete="off" autofocus>
                </div>
            </div>
            <div class="search-results mobile-results" id="mobileSearchResults"></div>
        </div>
    </div>

    <!-- Main Content -->
    <main>
        <!-- Hero Section -->
        <section class="hero-section">
            <img id="heroBackdrop" class="hero-image" alt="Hero backdrop">
            <div class="hero-overlay"></div>
            <div class="hero-content">
                <!-- Content will be dynamically loaded -->
            </div>
        </section>

        <div class="container-cinebrain">
            <!-- Content Container -->
            <div id="content-container" class="content-container-cinebrain">
                <!-- Content rows will be dynamically inserted here -->
            </div>

            <!-- Top 10 Section -->
            <section class="top-10-section">
                <div class="section-header">
                    <h2 class="section-title">🔥 Top 10 Today</h2>
                    <p class="section-subtitle">Most watched content right now</p>
                </div>
                <div class="top-10-list" id="top10List">
                    <!-- Top 10 items will be loaded here -->
                </div>
            </section>
        </div>
    </main>

    <!-- Mobile Bottom Navigation -->
    <nav class="mobile-bottom-nav" id="mobileBottomNav" aria-label="Mobile navigation">
        <div class="mobile-nav-container" id="mobileNavContainer"></div>
    </nav>

    <!-- More Menu Overlay -->
    <div class="mobile-menu-overlay" id="mobileMenuOverlay" aria-hidden="true">
        <div class="menu-handle" role="presentation"></div>
        <div class="menu-header">
            <h3 class="menu-title">Discover</h3>
            <button class="menu-close-btn" id="mobileMenuClose" aria-label="Close menu">
                <i data-feather="x"></i>
            </button>
        </div>
        <div class="menu-section">
            <h4 class="menu-section-title">Browse</h4>
            <div class="mobile-menu-grid" id="mobileMenuGrid"></div>
        </div>
        <div class="menu-section">
            <h4 class="menu-section-title" id="userSectionTitle">Account</h4>
            <div class="mobile-menu-list" id="mobileMenuList"></div>
        </div>
        <div class="menu-footer">
            <div class="menu-footer-info">
                <span class="app-version">CineBrain v1.0.0</span>
                <span class="menu-footer-separator">•</span>
                <a href="/pages/privacy.html" class="menu-footer-link">Privacy</a>
                <span class="menu-footer-separator">•</span>
                <a href="/pages/terms.html" class="menu-footer-link">Terms</a>
            </div>
        </div>
    </div>

    <!-- Backdrop -->
    <div class="mobile-backdrop" id="mobileBackdrop" aria-hidden="true"></div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>

    <!-- Custom JavaScript (ORDER IS IMPORTANT) -->
    <script src="/js/theme-manager.js"></script>
    <script src="/js/topbar.js"></script>
    <script src="/js/mobile-nav.js"></script>
    <script src="/js/trending.js"></script>

</body>

</html>


2. trending.css

/* Trending Page Styles - Unified with CineBrain Theme System */

/* Inherit all variables from topbar and content-card */
:root {
/* Trending-specific variables with responsive sizing */
--hero-height: clamp(350px, 60vh, 600px);
--hero-mobile-height: clamp(300px, 50vh, 450px);
--hero-content-padding: clamp(1.5rem, 4vw, 2.5rem);
--hero-overlay-opacity: 0.85;
--top10-item-height: clamp(80px, 20vw, 120px);
--top10-poster-width: clamp(50px, 12vw, 80px);
--section-spacing: clamp(2rem, 6vw, 4rem);

/* Responsive text sizes - same system as content-card */
--hero-title-size: clamp(1.75rem, 6vw, 3.5rem);
--hero-badge-size: clamp(0.7rem, 2vw, 0.85rem);
--hero-info-size: clamp(0.85rem, 2.2vw, 1rem);
--hero-description-size: clamp(0.9rem, 2.3vw, 1.1rem);
--hero-btn-size: clamp(0.85rem, 2.2vw, 1rem);
--section-title-size: clamp(1.5rem, 4.5vw, 2.25rem);
--section-subtitle-size: clamp(0.9rem, 2.3vw, 1.1rem);
--top10-rank-size: clamp(1.25rem, 4vw, 2rem);
--top10-title-size: clamp(0.9rem, 2.5vw, 1.2rem);
--top10-meta-size: clamp(0.75rem, 2vw, 0.9rem);
--top10-btn-size: clamp(0.75rem, 2vw, 0.9rem);
}

/* Dark Theme Variables */
[data-theme="dark"] {
--hero-overlay-bg: linear-gradient(to bottom, transparent 0%, rgba(0, 0, 0, 0.4) 50%, rgba(0, 0, 0, 0.9) 100%);
--hero-text-primary: #ffffff;
--hero-text-secondary: rgba(255, 255, 255, 0.8);
--hero-text-muted: rgba(255, 255, 255, 0.6);
--hero-badge-bg: var(--cinebrain-red);
--hero-btn-primary-bg: #ffffff;
--hero-btn-primary-color: var(--cinebrain-dark);
--hero-btn-secondary-bg: rgba(255, 255, 255, 0.15);
--hero-btn-secondary-color: #ffffff;
--top10-item-bg: rgba(26, 31, 58, 0.6);
--top10-item-hover-bg: rgba(26, 31, 58, 0.8);
--top10-rank-gold: #FFD700;
--top10-rank-silver: #C0C0C0;
--top10-rank-bronze: #CD7F32;
--top10-rank-default: var(--cinebrain-red);
}

/* Light Theme Variables */
[data-theme="light"] {
--hero-overlay-bg: linear-gradient(to bottom, transparent 0%, rgba(0, 0, 0, 0.3) 50%, rgba(0, 0, 0, 0.8) 100%);
--hero-text-primary: #ffffff;
--hero-text-secondary: rgba(255, 255, 255, 0.9);
--hero-text-muted: rgba(255, 255, 255, 0.7);
--hero-badge-bg: var(--cinebrain-blue);
--hero-btn-primary-bg: #ffffff;
--hero-btn-primary-color: var(--cinebrain-dark);
--hero-btn-secondary-bg: rgba(255, 255, 255, 0.2);
--hero-btn-secondary-color: #ffffff;
--top10-item-bg: rgba(255, 255, 255, 0.95);
--top10-item-hover-bg: rgba(255, 255, 255, 1);
--top10-rank-gold: #FFD700;
--top10-rank-silver: #C0C0C0;
--top10-rank-bronze: #CD7F32;
--top10-rank-default: var(--cinebrain-blue);
}

/* Body padding adjustment for trending page */
body {
padding-top: var(--navbar-height);
}

/* Hero Section */
.hero-section {
position: relative;
width: 100%;
height: var(--hero-height);
margin-bottom: var(--section-spacing);
overflow: hidden;
background: var(--bs-body-bg);
border-radius: 0 0 clamp(12px, 3vw, 24px) clamp(12px, 3vw, 24px);
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}

@media (max-width: 768px) {
.hero-section {
height: var(--hero-mobile-height);
border-radius: 0 0 clamp(8px, 2vw, 16px) clamp(8px, 2vw, 16px);
}
}

.hero-image {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
object-fit: cover;
opacity: 0;
transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1);
filter: brightness(0.7);
}

.hero-image.loaded {
opacity: 1;
}

.hero-overlay {
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: var(--hero-overlay-bg);
z-index: 1;
}

.hero-content {
position: absolute;
bottom: 0;
left: 0;
right: 0;
padding: var(--hero-content-padding);
z-index: 2;
max-width: 1200px;
margin: 0 auto;
animation: fadeInUp 0.8s cubic-bezier(0.4, 0, 0.2, 1) 0.3s both;
}

@keyframes fadeInUp {
from {
opacity: 0;
transform: translateY(30px);
}

to {
opacity: 1;
transform: translateY(0);
}
}

.hero-badge {
display: inline-flex;
align-items: center;
gap: clamp(4px, 1vw, 6px);
background: var(--hero-badge-bg);
color: white;
padding: clamp(4px, 1vw, 6px) clamp(8px, 2vw, 12px);
border-radius: clamp(4px, 1vw, 6px);
font-size: var(--hero-badge-size);
font-weight: 700;
margin-bottom: clamp(8px, 2vw, 12px);
text-transform: uppercase;
letter-spacing: 0.5px;
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.hero-title {
font-size: var(--hero-title-size);
font-weight: 800;
color: var(--hero-text-primary);
margin-bottom: clamp(8px, 2vw, 12px);
line-height: 1.1;
text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
letter-spacing: -0.02em;
}

.hero-info {
display: flex;
align-items: center;
gap: clamp(8px, 2vw, 16px);
margin-bottom: clamp(12px, 3vw, 16px);
flex-wrap: wrap;
}

.hero-info span {
color: var(--hero-text-secondary);
font-size: var(--hero-info-size);
font-weight: 500;
display: flex;
align-items: center;
gap: clamp(3px, 0.8vw, 5px);
background: rgba(0, 0, 0, 0.3);
padding: clamp(3px, 0.8vw, 5px) clamp(6px, 1.5vw, 10px);
border-radius: clamp(3px, 0.8vw, 5px);
backdrop-filter: blur(5px);
-webkit-backdrop-filter: blur(5px);
}

.hero-description {
color: var(--hero-text-muted);
font-size: var(--hero-description-size);
line-height: 1.6;
margin-bottom: clamp(20px, 5vw, 28px);
max-width: clamp(300px, 80vw, 650px);
display: -webkit-box;
-webkit-line-clamp: 3;
-webkit-box-orient: vertical;
overflow: hidden;
text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
}

.hero-actions {
display: flex;
gap: clamp(8px, 2vw, 12px);
flex-wrap: wrap;
}

.hero-btn {
padding: clamp(10px, 2.5vw, 14px) clamp(16px, 4vw, 24px);
border-radius: clamp(6px, 1.5vw, 10px);
font-size: var(--hero-btn-size);
font-weight: 600;
border: none;
cursor: pointer;
transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
display: inline-flex;
align-items: center;
justify-content: center;
gap: clamp(6px, 1.5vw, 8px);
min-width: clamp(100px, 25vw, 140px);
text-decoration: none;
-webkit-tap-highlight-color: transparent;
position: relative;
overflow: hidden;
}

.hero-btn::before {
content: '';
position: absolute;
top: 0;
left: -100%;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
transition: left 0.5s;
}

.hero-btn:hover::before {
left: 100%;
}

.hero-btn-secondary {
background: var(--hero-btn-secondary-bg);
color: var(--hero-btn-secondary-color);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid rgba(255, 255, 255, 0.2);
}

.hero-btn-secondary:hover {
background: rgba(255, 255, 255, 0.25);
transform: translateY(-1px);
box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
}

.hero-btn:active {
transform: translateY(0);
}

/* Top 10 Section */
.top-10-section {
margin: var(--section-spacing) 0;
padding: 0 clamp(12px, 3vw, 20px);
}

.section-header {
margin-bottom: clamp(16px, 4vw, 24px);
text-align: center;
}

.section-title {
font-size: var(--section-title-size);
font-weight: 800;
background: linear-gradient(135deg, var(--cinebrain-red), var(--cinebrain-purple));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin-bottom: clamp(6px, 1.5vw, 10px);
letter-spacing: -0.02em;
}

.section-subtitle {
color: var(--text-secondary);
font-size: var(--section-subtitle-size);
font-weight: 400;
}

.top-10-list {
display: flex;
flex-direction: column;
gap: clamp(8px, 2vw, 12px);
max-width: 1000px;
margin: 0 auto;
}

.top-10-item {
display: flex;
align-items: center;
gap: clamp(12px, 3vw, 20px);
padding: clamp(12px, 3vw, 16px);
background: var(--top10-item-bg);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border-radius: clamp(10px, 2.5vw, 16px);
border: 1px solid var(--search-border);
transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
cursor: pointer;
position: relative;
overflow: hidden;
min-height: var(--top10-item-height);
box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.top-10-item::before {
content: '';
position: absolute;
top: 0;
left: -100%;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(229, 9, 20, 0.1), transparent);
transition: left 0.5s;
}

.top-10-item:hover::before {
left: 100%;
}

.top-10-item:hover {
background: var(--top10-item-hover-bg);
transform: translateX(clamp(4px, 1vw, 8px));
box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
border-color: var(--search-focus-border);
}

.item-rank {
font-size: var(--top10-rank-size);
font-weight: 900;
width: clamp(35px, 8vw, 50px);
text-align: center;
flex-shrink: 0;
text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
letter-spacing: -0.02em;
}

.item-rank.gold {
color: var(--top10-rank-gold);
}

.item-rank.silver {
color: var(--top10-rank-silver);
}

.item-rank.bronze {
color: var(--top10-rank-bronze);
}

.item-rank:not(.gold):not(.silver):not(.bronze) {
color: var(--top10-rank-default);
}

.item-poster {
width: var(--top10-poster-width);
height: calc(var(--top10-poster-width) * 1.5);
object-fit: cover;
border-radius: clamp(6px, 1.5vw, 10px);
flex-shrink: 0;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
transition: transform 0.3s ease;
}

.top-10-item:hover .item-poster {
transform: scale(1.05);
}

.item-details {
flex: 1;
min-width: 0;
display: flex;
flex-direction: column;
gap: clamp(4px, 1vw, 6px);
}

.item-title {
font-size: var(--top10-title-size);
font-weight: 700;
color: var(--text-primary);
margin: 0;
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
line-height: 1.3;
}

.item-meta {
display: flex;
align-items: center;
gap: clamp(6px, 1.5vw, 12px);
font-size: var(--top10-meta-size);
color: var(--text-secondary);
flex-wrap: wrap;
}

.item-meta span {
display: flex;
align-items: center;
gap: clamp(2px, 0.5vw, 4px);
background: var(--search-bg);
padding: clamp(2px, 0.5vw, 4px) clamp(6px, 1.5vw, 8px);
border-radius: clamp(3px, 0.8vw, 4px);
border: 1px solid var(--search-border);
font-weight: 500;
}

.item-actions {
display: flex;
gap: clamp(6px, 1.5vw, 8px);
flex-shrink: 0;
}

.item-btn {
padding: clamp(6px, 1.5vw, 10px) clamp(12px, 3vw, 16px);
border-radius: clamp(6px, 1.5vw, 8px);
font-size: var(--top10-btn-size);
font-weight: 600;
border: none;
cursor: pointer;
transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
white-space: nowrap;
display: inline-flex;
align-items: center;
justify-content: center;
gap: clamp(3px, 0.8vw, 5px);
min-width: clamp(70px, 18vw, 90px);
-webkit-tap-highlight-color: transparent;
}

.item-btn-add {
background: var(--search-bg);
color: var(--text-primary);
border: 1px solid var(--search-border);
}

.item-btn-add:hover {
background: var(--search-focus-bg);
border-color: var(--search-focus-border);
transform: translateY(-1px);
}

.item-btn-add.added {
background: linear-gradient(135deg, var(--cinebrain-purple), var(--cinebrain-blue));
color: white;
border-color: var(--cinebrain-purple);
}

.item-btn-add.added:hover {
filter: brightness(1.1);
}

/* Mobile Responsive Adjustments */
@media (max-width: 768px) {
:root {
--hero-title-size: clamp(1.5rem, 5.5vw, 2.5rem);
--hero-badge-size: clamp(0.65rem, 1.8vw, 0.8rem);
--hero-info-size: clamp(0.8rem, 2vw, 0.95rem);
--hero-description-size: clamp(0.85rem, 2.1vw, 1rem);
--hero-btn-size: clamp(0.8rem, 2vw, 0.95rem);
--section-title-size: clamp(1.3rem, 4vw, 2rem);
--section-subtitle-size: clamp(0.85rem, 2.1vw, 1rem);
--top10-rank-size: clamp(1.1rem, 3.5vw, 1.75rem);
--top10-title-size: clamp(0.85rem, 2.3vw, 1.1rem);
--top10-meta-size: clamp(0.7rem, 1.8vw, 0.85rem);
--top10-btn-size: clamp(0.7rem, 1.8vw, 0.85rem);
}

.hero-content {
padding: clamp(1rem, 4vw, 1.5rem);
}

.hero-actions {
justify-content: center;
}

.hero-btn {
flex: 1;
min-width: auto;
max-width: 150px;
}

.top-10-item {
padding: clamp(10px, 2.5vw, 12px);
gap: clamp(10px, 2.5vw, 15px);
}

.item-actions {
flex-direction: column;
gap: clamp(4px, 1vw, 6px);
min-width: clamp(80px, 20vw, 100px);
}

.item-btn {
padding: clamp(5px, 1.2vw, 8px) clamp(8px, 2vw, 12px);
min-width: auto;
}
}

@media (max-width: 480px) {
:root {
--hero-title-size: clamp(1.3rem, 5vw, 2rem);
--hero-badge-size: clamp(0.6rem, 1.6vw, 0.75rem);
--hero-info-size: clamp(0.75rem, 1.9vw, 0.9rem);
--hero-description-size: clamp(0.8rem, 2vw, 0.95rem);
--hero-btn-size: clamp(0.75rem, 1.9vw, 0.9rem);
--section-title-size: clamp(1.2rem, 3.8vw, 1.8rem);
--section-subtitle-size: clamp(0.8rem, 2vw, 0.95rem);
--top10-rank-size: clamp(1rem, 3.2vw, 1.5rem);
--top10-title-size: clamp(0.8rem, 2.1vw, 1rem);
--top10-meta-size: clamp(0.65rem, 1.7vw, 0.8rem);
--top10-btn-size: clamp(0.65rem, 1.7vw, 0.8rem);
}

.hero-info {
justify-content: center;
}

.hero-description {
text-align: center;
-webkit-line-clamp: 2;
}

.item-actions {
display: none;
}

.top-10-item {
padding: clamp(8px, 2vw, 10px);
gap: clamp(8px, 2vw, 12px);
}

.item-rank {
width: clamp(30px, 7vw, 40px);
}

.item-poster {
width: clamp(40px, 10vw, 60px);
height: calc(clamp(40px, 10vw, 60px) * 1.5);
}
}

/* Ultra small devices */
@media (max-width: 320px) {
:root {
--hero-title-size: clamp(1.1rem, 4.5vw, 1.6rem);
--hero-badge-size: clamp(0.55rem, 1.4vw, 0.7rem);
--hero-info-size: clamp(0.7rem, 1.8vw, 0.85rem);
--hero-description-size: clamp(0.75rem, 1.9vw, 0.9rem);
--hero-btn-size: clamp(0.7rem, 1.8vw, 0.85rem);
--section-title-size: clamp(1.1rem, 3.5vw, 1.6rem);
--section-subtitle-size: clamp(0.75rem, 1.9vw, 0.9rem);
--top10-rank-size: clamp(0.9rem, 3vw, 1.3rem);
--top10-title-size: clamp(0.75rem, 2vw, 0.95rem);
--top10-meta-size: clamp(0.6rem, 1.6vw, 0.75rem);
--top10-btn-size: clamp(0.6rem, 1.6vw, 0.75rem);
}
}

/* Large screens */
@media (min-width: 1200px) {
:root {
--hero-title-size: clamp(2.5rem, 4vw, 3.5rem);
--hero-badge-size: clamp(0.8rem, 1.2vw, 0.9rem);
--hero-info-size: clamp(0.95rem, 1.4vw, 1.1rem);
--hero-description-size: clamp(1rem, 1.5vw, 1.2rem);
--hero-btn-size: clamp(0.95rem, 1.4vw, 1.1rem);
--section-title-size: clamp(2rem, 3vw, 2.5rem);
--section-subtitle-size: clamp(1rem, 1.5vw, 1.2rem);
--top10-rank-size: clamp(1.75rem, 2.5vw, 2.2rem);
--top10-title-size: clamp(1.1rem, 1.6vw, 1.3rem);
--top10-meta-size: clamp(0.85rem, 1.3vw, 1rem);
--top10-btn-size: clamp(0.85rem, 1.3vw, 1rem);
}
}

/* Loading States */
.hero-skeleton {
background: linear-gradient(90deg, var(--skeleton-bg) 0%, var(--skeleton-shine) 50%, var(--skeleton-bg) 100%);
background-size: 200% 100%;
animation: skeleton-loading 1.5s infinite;
border-radius: clamp(4px, 1vw, 6px);
}

@keyframes skeleton-loading {
0% {
background-position: 200% 0;
}

100% {
background-position: -200% 0;
}
}

.hero-title-skeleton {
height: clamp(40px, 8vw, 60px);
width: 60%;
margin-bottom: clamp(8px, 2vw, 12px);
}

.hero-info-skeleton {
height: clamp(20px, 4vw, 24px);
width: 40%;
margin-bottom: clamp(12px, 3vw, 16px);
}

.hero-description-skeleton {
height: clamp(60px, 12vw, 80px);
width: 80%;
margin-bottom: clamp(20px, 5vw, 28px);
}

.top10-skeleton {
display: flex;
align-items: center;
gap: clamp(12px, 3vw, 20px);
padding: clamp(12px, 3vw, 16px);
background: var(--top10-item-bg);
border-radius: clamp(10px, 2.5vw, 16px);
border: 1px solid var(--search-border);
min-height: var(--top10-item-height);
}

.top10-rank-skeleton {
width: clamp(35px, 8vw, 50px);
height: clamp(25px, 6vw, 35px);
background: var(--skeleton-bg);
border-radius: clamp(4px, 1vw, 6px);
}

.top10-poster-skeleton {
width: var(--top10-poster-width);
height: calc(var(--top10-poster-width) * 1.5);
background: var(--skeleton-bg);
border-radius: clamp(6px, 1.5vw, 10px);
}

.top10-details-skeleton {
flex: 1;
display: flex;
flex-direction: column;
gap: clamp(6px, 1.5vw, 8px);
}

.top10-title-skeleton {
height: clamp(16px, 4vw, 20px);
width: 70%;
background: var(--skeleton-bg);
border-radius: clamp(3px, 0.8vw, 4px);
}

.top10-meta-skeleton {
height: clamp(12px, 3vw, 16px);
width: 50%;
background: var(--skeleton-bg);
border-radius: clamp(3px, 0.8vw, 4px);
}

/* Error States */
.error-hero {
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
height: 100%;
text-align: center;
color: var(--text-secondary);
padding: var(--hero-content-padding);
}

.error-hero h2 {
font-size: clamp(1.5rem, 4vw, 2rem);
margin-bottom: clamp(8px, 2vw, 12px);
color: var(--text-primary);
}

.error-hero p {
font-size: clamp(0.9rem, 2.3vw, 1.1rem);
margin-bottom: clamp(16px, 4vw, 24px);
}

.retry-hero-btn {
padding: clamp(10px, 2.5vw, 14px) clamp(20px, 5vw, 28px);
background: linear-gradient(135deg, var(--cinebrain-red), var(--cinebrain-purple));
color: white;
border: none;
border-radius: clamp(6px, 1.5vw, 10px);
font-size: clamp(0.9rem, 2.3vw, 1rem);
font-weight: 600;
cursor: pointer;
transition: all 0.3s ease;
}

.retry-hero-btn:hover {
transform: translateY(-2px);
box-shadow: 0 4px 15px rgba(229, 9, 20, 0.3);
}

/* Custom Notification System for Trending Page */
.trending-notification {
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
user-select: none;
-webkit-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
z-index: 10001 !important;
}

/* Notification Animations */
@keyframes slideUpFade {
from {
opacity: 0;
transform: translateX(-50%) translateY(20px);
}

to {
opacity: 1;
transform: translateX(-50%) translateY(0);
}
}

@keyframes slideDownFade {
from {
opacity: 1;
transform: translateX(-50%) translateY(0);
}

to {
opacity: 0;
transform: translateX(-50%) translateY(20px);
}
}

.trending-notification {
pointer-events: auto;
cursor: pointer;
transition: all 0.2s ease;
}

.trending-notification:hover {
transform: translateX(-50%) translateY(-2px) !important;
box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4) !important;
}

.trending-notification:active {
transform: translateX(-50%) translateY(0px) !important;
}

/* Responsive notification adjustments */
@media (max-width: 320px) {
.trending-notification {
font-size: 12px !important;
padding: 10px 14px !important;
min-width: 180px !important;
}
}

@media (max-width: 280px) {
.trending-notification {
font-size: 11px !important;
padding: 8px 12px !important;
min-width: 160px !important;
max-width: calc(100vw - 24px) !important;
}
}

@media (orientation: landscape) and (max-height: 500px) {
.trending-notification {
bottom: 60px !important;
}
}

@media (orientation: landscape) and (max-height: 400px) {
.trending-notification {
bottom: 40px !important;
font-size: 12px !important;
padding: 8px 16px !important;
}
}

/* High contrast mode support */
@media (prefers-contrast: high) {
.hero-overlay {
background: linear-gradient(to bottom, transparent 0%, rgba(0, 0, 0, 0.6) 50%, rgba(0, 0, 0, 0.95) 100%);
}

.top-10-item {
border-width: 2px;
}

.hero-btn,
.item-btn {
border: 2px solid currentColor;
}

.trending-notification {
border-width: 2px !important;
font-weight: 600 !important;
}
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {

*,
*::before,
*::after {
animation-duration: 0.01ms !important;
animation-iteration-count: 1 !important;
transition-duration: 0.01ms !important;
}

.hero-btn::before,
.top-10-item::before {
display: none;
}

.trending-notification {
animation: none !important;
transition: none !important;
}
}

/* Dark theme specific adjustments for notifications */
[data-theme="dark"] .trending-notification {
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5) !important;
}

/* Light theme specific adjustments for notifications */
[data-theme="light"] .trending-notification {
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2) !important;
}

/* Accessibility */
.hero-btn:focus-visible,
.item-btn:focus-visible,
.top-10-item:focus-visible {
outline: 2px solid var(--search-focus-border);
outline-offset: 2px;
}

/* Print styles */
@media print {
.hero-section {
height: auto;
min-height: 200px;
page-break-inside: avoid;
}

.hero-actions,
.item-actions {
display: none !important;
}

.top-10-list {
page-break-inside: avoid;
}

.top-10-item {
page-break-inside: avoid;
margin-bottom: 10px;
}

.trending-notification {
display: none !important;
}
}

3. trending.js

/**
* CineBrain Trending Page Manager
* Integrated with content-card system and theme management
* Updated with small top-right notification system
*/

class TrendingPageManager {
constructor() {
// API Configuration - Same as other components
this.apiBase = 'https://backend-app-970m.onrender.com/api';
this.posterBase = 'https://image.tmdb.org/t/p/w500';
this.backdropBase = 'https://image.tmdb.org/t/p/w1280';

// Authentication state
this.authToken = localStorage.getItem('cinebrain-token');
this.isAuthenticated = !!this.authToken;
this.currentUser = this.getCurrentUser();

// User data
this.userWishlist = new Set();
this.contentCache = new Map();
this.interactionStates = new Map();

// Loading states
this.isLoadingHero = false;
this.isLoadingTop10 = false;

// Content row configurations for trending page
this.contentRows = [
{
id: 'trending-movies',
title: '🔥 Trending Movies',
endpoint: '/recommendations/trending',
params: { category: 'movies', limit: 20 }
},
{
id: 'trending-tv',
title: '📺 Trending TV Shows',
endpoint: '/recommendations/trending',
params: { category: 'tv_shows', limit: 20 }
},
{
id: 'trending-anime',
title: '🎌 Trending Anime',
endpoint: '/recommendations/anime',
params: { limit: 20 }
},
{
id: 'rising-fast',
title: '⚡ Rising Fast',
endpoint: '/recommendations/new-releases',
params: { type: 'movie', limit: 20 }
},
{
id: 'popular-nearby',
title: '🌍 Popular in Your Region',
endpoint: '/recommendations/trending',
params: { category: 'all', limit: 20, region: 'IN' }
},
{
id: 'critics-choice',
title: '🏆 Critics Choice',
endpoint: '/recommendations/critics-choice',
params: { type: 'movie', limit: 20 }
}
];

// Register with theme manager if available
if (window.themeManager) {
window.themeManager.register((theme) => this.onThemeChange(theme));
}

this.init();
}

/**
* Custom notification system - Small, Top Right positioned
*/
showNotification(message, type = 'info', duration = 3000) {
// Remove any existing notifications first
const existingNotifications = document.querySelectorAll('.trending-notification');
existingNotifications.forEach(notification => notification.remove());

const notification = document.createElement('div');
notification.className = `trending-notification trending-notification-${type}`;

// Define colors based on type
const colors = {
success: {
bg: 'linear-gradient(135deg, #10b981, #059669)',
border: 'rgba(5, 150, 105, 0.3)',
icon: '✓'
},
error: {
bg: 'linear-gradient(135deg, #ef4444, #dc2626)',
border: 'rgba(220, 38, 38, 0.3)',
icon: '✕'
},
warning: {
bg: 'linear-gradient(135deg, #f59e0b, #d97706)',
border: 'rgba(217, 119, 6, 0.3)',
icon: '⚠'
},
info: {
bg: 'linear-gradient(135deg, #3b82f6, #2563eb)',
border: 'rgba(37, 99, 235, 0.3)',
icon: 'ℹ'
}
};

const config = colors[type] || colors.info;

// Small notification at top right
notification.style.cssText = `
position: fixed;
top: calc(var(--navbar-height, 60px) + 20px);
right: 20px;
background: ${config.bg};
color: white;
padding: 10px 16px;
border-radius: 8px;
font-size: 13px;
font-weight: 500;
z-index: 10001;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
backdrop-filter: blur(10px);
-webkit-backdrop-filter: blur(10px);
border: 1px solid ${config.border};
max-width: 280px;
min-width: 200px;
display: flex;
align-items: center;
gap: 8px;
animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
line-height: 1.4;
cursor: pointer;
transition: all 0.2s ease;
transform-origin: right top;
`;

// Add icon and message
notification.innerHTML = `
<span style="
                font-size: 14px;
                font-weight: 600;
                flex-shrink: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 18px;
                height: 18px;
                background: rgba(255, 255, 255, 0.2);
                border-radius: 50%;
                line-height: 1;
            ">${config.icon}</span>
<span style="
                flex: 1;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            ">${message}</span>
`;

// Add to DOM
document.body.appendChild(notification);

// Add CSS animations if not already present
if (!document.getElementById('trending-notification-styles')) {
const style = document.createElement('style');
style.id = 'trending-notification-styles';
style.textContent = `
@keyframes slideInRight {
from {
opacity: 0;
transform: translateX(100%);
}
to {
opacity: 1;
transform: translateX(0);
}
}

@keyframes slideOutRight {
from {
opacity: 1;
transform: translateX(0);
}
to {
opacity: 0;
transform: translateX(100%);
}
}

.trending-notification:hover {
transform: scale(1.02);
box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
}

.trending-notification:active {
transform: scale(0.98);
}

/* Mobile adjustments */
@media (max-width: 768px) {
.trending-notification {
top: calc(var(--navbar-height, 60px) + 10px) !important;
right: 10px !important;
max-width: calc(100vw - 80px) !important;
font-size: 12px !important;
padding: 8px 14px !important;
}
}

@media (max-width: 480px) {
.trending-notification {
max-width: calc(100vw - 60px) !important;
font-size: 11px !important;
padding: 8px 12px !important;
}
}
`;
document.head.appendChild(style);
}

// Auto remove after duration
const removeNotification = () => {
notification.style.animation = 'slideOutRight 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
setTimeout(() => {
if (notification.parentNode) {
notification.remove();
}
}, 300);
};

const timeoutId = setTimeout(removeNotification, duration);

// Click to dismiss
notification.addEventListener('click', () => {
clearTimeout(timeoutId);
removeNotification();
});
}

/**
* Get current user from localStorage
*/
getCurrentUser() {
const userStr = localStorage.getItem('cinebrain-user');
if (userStr) {
try {
return JSON.parse(userStr);
} catch (e) {
console.error('Error parsing user data:', e);
return null;
}
}
return null;
}

/**
* Theme change callback from Theme Manager
*/
onThemeChange(theme) {
console.log('Trending page theme updated to:', theme);

// Re-initialize feather icons if needed
if (typeof feather !== 'undefined') {
feather.replace();
}

// Update any dynamic theme-dependent elements
this.updateThemeElements();
}

/**
* Update theme-dependent elements
*/
updateThemeElements() {
// Update any elements that need manual theme updates
const heroButtons = document.querySelectorAll('.hero-btn');
heroButtons.forEach(btn => {
// Force repaint for gradient updates
btn.style.transform = 'translateZ(0)';
setTimeout(() => {
btn.style.transform = '';
}, 0);
});
}

/**
* Initialize the trending page
*/
async init() {
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', () => this.setup());
} else {
this.setup();
}
}

/**
* Setup the trending page
*/
async setup() {
try {
// Show loading states
this.showHeroSkeleton();
this.showTop10Skeleton();

// Load user wishlist if authenticated
if (this.isAuthenticated) {
await this.loadUserWishlist();
}

// Load hero content first (priority)
await this.loadHeroContent();

// Create content rows using same system as content-card
this.createContentRows();

// Load all content with staggered loading
await this.loadAllContent();

// Setup event listeners
this.setupEventListeners();

// Initialize feather icons
if (typeof feather !== 'undefined') {
feather.replace();
}

console.log('Trending page setup completed successfully');

} catch (error) {
console.error('Error setting up trending page:', error);
this.showHeroError();
}
}

/**
* Load user wishlist
*/
async loadUserWishlist() {
if (!this.isAuthenticated) return;

try {
const response = await fetch(`${this.apiBase}/user/watchlist`, {
headers: { 'Authorization': `Bearer ${this.authToken}` }
});

if (response.ok) {
const data = await response.json();
this.userWishlist.clear();
this.interactionStates.clear();

if (data.watchlist && Array.isArray(data.watchlist)) {
data.watchlist.forEach(item => {
this.userWishlist.add(item.id);
this.interactionStates.set(item.id, 'watchlist');
});
}
console.log('Loaded wishlist with', this.userWishlist.size, 'items');

// Update all wishlist buttons after loading
this.updateWishlistButtons();
} else if (response.status === 401) {
// Token might be expired
console.error('Authentication failed, clearing token');
localStorage.removeItem('cinebrain-token');
this.authToken = null;
this.isAuthenticated = false;
this.userWishlist.clear();
this.interactionStates.clear();
}
} catch (error) {
console.error('Error loading wishlist:', error);
}
}

/**
* Sync wishlist state with backend
*/
async syncWishlistState() {
if (!this.isAuthenticated) {
this.userWishlist.clear();
this.interactionStates.clear();
this.updateWishlistButtons();
return;
}

try {
await this.loadUserWishlist();
} catch (error) {
console.error('Error syncing wishlist state:', error);
}
}

/**
* Show hero skeleton loading state
*/
showHeroSkeleton() {
const heroContent = document.querySelector('.hero-content');
if (!heroContent) return;

heroContent.innerHTML = `
<div class="hero-skeleton hero-title-skeleton"></div>
<div class="hero-skeleton hero-info-skeleton"></div>
<div class="hero-skeleton hero-description-skeleton"></div>
<div class="hero-actions">
    <div class="hero-skeleton" style="width: 120px; height: 44px; border-radius: 8px;"></div>
    <div class="hero-skeleton" style="width: 100px; height: 44px; border-radius: 8px;"></div>
</div>
`;
}

/**
* Show top 10 skeleton loading state
*/
showTop10Skeleton() {
const top10List = document.getElementById('top10List');
if (!top10List) return;

top10List.innerHTML = Array(10).fill('').map((_, index) => `
<div class="top10-skeleton">
    <div class="top10-rank-skeleton"></div>
    <div class="top10-poster-skeleton"></div>
    <div class="top10-details-skeleton">
        <div class="top10-title-skeleton"></div>
        <div class="top10-meta-skeleton"></div>
    </div>
</div>
`).join('');
}

/**
* Load hero content
*/
async loadHeroContent() {
if (this.isLoadingHero) return;
this.isLoadingHero = true;

try {
const response = await fetch(`${this.apiBase}/recommendations/trending?category=all&limit=1`);
if (!response.ok) throw new Error('Failed to fetch hero content');

const data = await response.json();
let heroContent = null;

// Handle different response structures
if (data.categories) {
// Get first item from any category
for (const categoryItems of Object.values(data.categories)) {
if (Array.isArray(categoryItems) && categoryItems.length > 0) {
heroContent = categoryItems[0];
break;
}
}
} else if (data.recommendations && data.recommendations.length > 0) {
heroContent = data.recommendations[0];
}

if (heroContent) {
await this.displayHeroContent(heroContent);
} else {
throw new Error('No hero content available');
}

} catch (error) {
console.error('Error loading hero content:', error);
this.showHeroError();
} finally {
this.isLoadingHero = false;
}
}

/**
* Display hero content
*/
async displayHeroContent(content) {
try {
// Set backdrop image with loading
await this.loadHeroBackdrop(content);

// Update hero content with animation
const heroContent = document.querySelector('.hero-content');
if (!heroContent) return;

const isInWishlist = this.userWishlist.has(content.id);
const rating = this.formatRating(content.rating);
const year = this.extractYear(content.release_date);
const genres = content.genres?.slice(0, 2).join(' • ') || 'Action';
const contentType = (content.content_type || 'Movie').toUpperCase();

heroContent.innerHTML = `
<span class="hero-badge">
    🔥 #1 Trending
</span>
<h1 class="hero-title">${this.escapeHtml(content.title || 'Untitled')}</h1>
<div class="hero-info">
    <span>⭐ ${rating}</span>
    <span>${contentType}</span>
    ${year ? `<span>${year}</span>` : ''}
    <span>${genres}</span>
</div>
<p class="hero-description">${this.escapeHtml(content.overview || 'No description available.')}</p>
<div class="hero-actions">
    <button class="hero-btn hero-btn-secondary ${isInWishlist ? 'added' : ''}" id="heroWatchlistBtn"
        data-content-id="${content.id}">
        ${isInWishlist ? '✓ In List' : '+ My List'}
    </button>
    <button class="hero-btn hero-btn-secondary" id="heroInfoBtn">
        ⓘ More Info
    </button>
</div>
`;

// Setup button event listeners
this.setupHeroButtons(content);

} catch (error) {
console.error('Error displaying hero content:', error);
this.showHeroError();
}
}

/**
* Load hero backdrop image
*/
async loadHeroBackdrop(content) {
return new Promise((resolve) => {
const heroBackdrop = document.getElementById('heroBackdrop');
if (!heroBackdrop) {
resolve();
return;
}

if (content.backdrop_path || content.poster_path) {
const backdropUrl = content.backdrop_path
? `${this.backdropBase}${content.backdrop_path}`
: this.formatPosterUrl(content.poster_path);

const img = new Image();
img.onload = () => {
heroBackdrop.src = backdropUrl;
heroBackdrop.classList.add('loaded');
resolve();
};
img.onerror = () => {
console.warn('Failed to load hero backdrop');
resolve();
};
img.src = backdropUrl;
} else {
resolve();
}
});
}

/**
* Setup hero button event listeners
*/
setupHeroButtons(content) {
const watchlistBtn = document.getElementById('heroWatchlistBtn');
const infoBtn = document.getElementById('heroInfoBtn');

if (watchlistBtn) {
watchlistBtn.addEventListener('click', () => this.handleWishlistClick(content.id, watchlistBtn));
}

if (infoBtn) {
infoBtn.addEventListener('click', () => this.redirectToDetails(content));
}
}

/**
* Show hero error state
*/
showHeroError() {
const heroContent = document.querySelector('.hero-content');
if (!heroContent) return;

heroContent.innerHTML = `
<div class="error-hero">
    <h2>Unable to Load Content</h2>
    <p>Please check your connection and try again</p>
    <button class="retry-hero-btn" onclick="trendingManager.loadHeroContent()">
        Retry
    </button>
</div>
`;
}

/**
* Create content rows
*/
createContentRows() {
const container = document.getElementById('content-container');
if (!container) return;

this.contentRows.forEach(rowConfig => {
const row = this.createCarouselRow(rowConfig);
container.appendChild(row);
});
}

/**
* Create carousel row (same as content-card)
*/
createCarouselRow(rowConfig) {
const row = document.createElement('div');
row.className = 'content-row';
row.id = rowConfig.id;

row.innerHTML = `
<div class="row-header">
    <h2 class="row-title">${rowConfig.title}</h2>
    <a href="/browse/${rowConfig.id}" class="see-all">See All →</a>
</div>
<div class="carousel-container">
    <button class="carousel-nav prev" aria-label="Previous">
        <svg viewBox="0 0 24 24">
            <path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                d="M15 18l-6-6 6-6" />
        </svg>
    </button>
    <div class="carousel-wrapper">
        ${this.createSkeletons(8)}
    </div>
    <button class="carousel-nav next" aria-label="Next">
        <svg viewBox="0 0 24 24">
            <path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                d="M9 18l6-6-6-6" />
        </svg>
    </button>
</div>
`;

return row;
}

/**
* Create skeleton loading cards
*/
createSkeletons(count) {
return Array(count).fill('').map(() => `
<div class="skeleton-card">
    <div class="skeleton skeleton-poster"></div>
    <div class="skeleton skeleton-title"></div>
    <div class="skeleton skeleton-meta"></div>
</div>
`).join('');
}

/**
* Load all content with staggered loading
*/
async loadAllContent() {
try {
// Load content rows with staggered timing
for (let i = 0; i < this.contentRows.length; i++) { const rowConfig=this.contentRows[i]; setTimeout(()=> {
    this.loadContentRow(rowConfig);
    }, i * 200); // Increased delay for better UX
    }

    // Load top 10 list
    setTimeout(() => {
    this.loadTop10List();
    }, this.contentRows.length * 200);

    } catch (error) {
    console.error('Error loading all content:', error);
    }
    }

    /**
    * Load content row (same as content-card)
    */
    async loadContentRow(rowConfig) {
    const row = document.getElementById(rowConfig.id);
    if (!row) return;

    const wrapper = row.querySelector('.carousel-wrapper');
    if (!wrapper) return;

    try {
    const content = await this.fetchContent(rowConfig.endpoint, rowConfig.params);

    wrapper.innerHTML = '';

    if (!content || content.length === 0) {
    wrapper.innerHTML = `
    <div class="error-message">
        <p>No content available</p>
    </div>
    `;
    return;
    }

    // Add content cards
    content.forEach(item => {
    const card = this.createContentCard(item);
    wrapper.appendChild(card);
    });

    // Setup navigation
    this.setupCarouselNavigation(row);

    } catch (error) {
    console.error(`Error loading ${rowConfig.title}:`, error);
    wrapper.innerHTML = `
    <div class="error-message">
        <h3>Unable to load content</h3>
        <p>Please check your connection and try again</p>
        <button class="retry-btn" onclick="trendingManager.loadContentRow(${JSON.stringify(rowConfig).replace(/"
            /g, '&quot;' )})">Retry</button>
    </div>
    `;
    }
    }

    /**
    * Create content card
    */
    createContentCard(content) {
    const card = document.createElement('div');
    card.className = 'content-card';
    card.dataset.contentId = content.id;

    const posterUrl = this.formatPosterUrl(content.poster_path);
    const rating = this.formatRating(content.rating);
    const year = this.extractYear(content.release_date);
    const genres = content.genres?.slice(0, 2) || [];
    const contentType = content.content_type || 'movie';
    const runtime = this.formatRuntime(content.runtime);
    const isInWishlist = this.userWishlist.has(content.id);

    card.innerHTML = `
    <div class="card-poster-container">
        <img class="card-poster" data-src="${posterUrl}" alt="${this.escapeHtml(content.title || 'Content')}"
            loading="lazy">
        <div class="content-type-badge ${contentType}">
            ${contentType.toUpperCase()}
        </div>
        <div class="card-overlays">
            <div class="card-top-overlay">
                <div></div>
                <button class="wishlist-btn ${isInWishlist ? 'active' : ''}" data-content-id="${content.id}"
                    title="${isInWishlist ? 'Remove from Wishlist' : 'Add to Wishlist'}"
                    aria-label="${isInWishlist ? 'Remove from Wishlist' : 'Add to Wishlist'}">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z" />
                    </svg>
                </button>
            </div>
            <div class="card-bottom-overlay">
                <div class="rating-badge">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z" />
                    </svg>
                    <span>${rating}</span>
                </div>
            </div>
        </div>
    </div>
    <div class="card-info">
        <div class="card-title">${this.escapeHtml(content.title || 'Unknown')}</div>
        <div class="card-meta">
            ${year ? `<span class="card-year">${year}</span>` : ''}
            ${runtime ? `<span class="card-runtime">• ${runtime}</span>` : ''}
        </div>
        ${genres.length > 0 ? `
        <div class="card-genres">
            ${genres.map(genre => `<span class="genre-chip">${this.escapeHtml(genre)}</span>`).join('')}
        </div>
        ` : ''}
    </div>
    `;

    // Setup event handlers
    this.setupCardHandlers(card, content);
    this.setupLazyLoading(card);

    return card;
    }

    /**
    * Setup card event handlers
    */
    setupCardHandlers(card, content) {
    // Card click handler - redirect to details page
    card.addEventListener('click', (e) => {
    if (!e.target.closest('.wishlist-btn')) {
    this.redirectToDetails(content);
    }
    });

    // Wishlist button handler
    const wishlistBtn = card.querySelector('.wishlist-btn');
    wishlistBtn?.addEventListener('click', async (e) => {
    e.stopPropagation();
    await this.handleWishlistClick(content.id, wishlistBtn);
    });
    }

    /**
    * Setup lazy loading for images
    */
    setupLazyLoading(card) {
    const img = card.querySelector('.card-poster');
    const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
    if (entry.isIntersecting) {
    const imgSrc = img.dataset.src;
    if (imgSrc) {
    const tempImg = new Image();
    tempImg.onload = () => {
    img.src = imgSrc;
    img.classList.add('loaded');
    };
    tempImg.onerror = () => {
    img.src = this.getPlaceholderImage();
    img.classList.add('loaded');
    };
    tempImg.src = imgSrc;
    }
    observer.unobserve(img);
    }
    });
    }, {
    rootMargin: '50px',
    threshold: 0.01
    });
    observer.observe(img);
    }

    /**
    * Load top 10 list
    */
    async loadTop10List() {
    if (this.isLoadingTop10) return;
    this.isLoadingTop10 = true;

    try {
    const response = await fetch(`${this.apiBase}/recommendations/trending?category=all&limit=10`);
    if (!response.ok) throw new Error('Failed to fetch top 10');

    const data = await response.json();
    let top10Items = [];

    // Handle different response structures
    if (data.categories) {
    // Collect items from all categories
    Object.values(data.categories).forEach(categoryItems => {
    if (Array.isArray(categoryItems)) {
    top10Items.push(...categoryItems);
    }
    });

    // Take first 10 unique items
    const seenIds = new Set();
    top10Items = top10Items.filter(item => {
    if (item && item.id && !seenIds.has(item.id)) {
    seenIds.add(item.id);
    return true;
    }
    return false;
    }).slice(0, 10);
    } else if (data.recommendations) {
    top10Items = data.recommendations.slice(0, 10);
    }

    this.displayTop10List(top10Items);

    } catch (error) {
    console.error('Error loading top 10:', error);
    this.showTop10Error();
    } finally {
    this.isLoadingTop10 = false;
    }
    }

    /**
    * Display top 10 list
    */
    displayTop10List(items) {
    const container = document.getElementById('top10List');
    if (!container) return;

    container.innerHTML = '';

    if (!items || items.length === 0) {
    container.innerHTML = `
    <div class="error-message">
        <p>No top 10 data available</p>
    </div>
    `;
    return;
    }

    items.forEach((item, index) => {
    const listItem = this.createTop10Item(item, index + 1);
    container.appendChild(listItem);
    });
    }

    /**
    * Create top 10 list item
    */
    createTop10Item(item, rank) {
    const div = document.createElement('div');
    div.className = 'top-10-item';
    div.dataset.contentId = item.id;

    const posterUrl = this.formatPosterUrl(item.poster_path);
    const isInWishlist = this.userWishlist.has(item.id);
    const rating = this.formatRating(item.rating);
    const year = this.extractYear(item.release_date);
    const contentType = (item.content_type || 'movie').toUpperCase();

    // Determine rank color
    let rankClass = '';
    if (rank === 1) rankClass = 'gold';
    else if (rank === 2) rankClass = 'silver';
    else if (rank === 3) rankClass = 'bronze';

    div.innerHTML = `
    <div class="item-rank ${rankClass}">${rank}</div>
    <img src="${posterUrl}" alt="${this.escapeHtml(item.title)}" class="item-poster" loading="lazy">
    <div class="item-details">
        <div class="item-title">${this.escapeHtml(item.title || 'Unknown')}</div>
        <div class="item-meta">
            <span>⭐ ${rating}</span>
            <span>${contentType}</span>
            ${year ? `<span>${year}</span>` : ''}
        </div>
    </div>
    <div class="item-actions">
        <button class="item-btn item-btn-add wishlist-btn-top10 ${isInWishlist ? 'added' : ''}"
            data-content-id="${item.id}" title="${isInWishlist ? 'Remove from Wishlist' : 'Add to Wishlist'}">
            ${isInWishlist ? '✓ Added' : '+ Add'}
        </button>
    </div>
    `;

    // Setup event handlers
    this.setupTop10ItemHandlers(div, item);

    return div;
    }

    /**
    * Setup top 10 item event handlers
    */
    setupTop10ItemHandlers(div, item) {
    // Item click handler - redirect to details page
    div.addEventListener('click', (e) => {
    if (!e.target.closest('.item-actions')) {
    this.redirectToDetails(item);
    }
    });

    // Wishlist button
    const wishlistBtn = div.querySelector('.wishlist-btn-top10');
    wishlistBtn?.addEventListener('click', async (e) => {
    e.stopPropagation();
    await this.handleWishlistClick(item.id, wishlistBtn);
    });
    }

    /**
    * Show top 10 error state
    */
    showTop10Error() {
    const container = document.getElementById('top10List');
    if (!container) return;

    container.innerHTML = `
    <div class="error-message">
        <h3>Unable to load Top 10</h3>
        <p>Please check your connection and try again</p>
        <button class="retry-btn" onclick="trendingManager.loadTop10List()">Retry</button>
    </div>
    `;
    }

    /**
    * Fetch content from API
    */
    async fetchContent(endpoint, params = {}) {
    const queryString = new URLSearchParams(params).toString();
    const url = `${this.apiBase}${endpoint}${queryString ? '?' + queryString : ''}`;

    const headers = {};
    if (this.authToken) {
    headers['Authorization'] = `Bearer ${this.authToken}`;
    }

    try {
    const response = await fetch(url, {
    headers,
    timeout: 10000
    });

    if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();

    // Handle different response structures
    if (data.recommendations) {
    return Array.isArray(data.recommendations) ? data.recommendations : [];
    } else if (data.categories) {
    const allContent = [];
    Object.values(data.categories).forEach(categoryItems => {
    if (Array.isArray(categoryItems)) {
    allContent.push(...categoryItems);
    }
    });

    // Remove duplicates
    const uniqueContent = [];
    const seenIds = new Set();
    allContent.forEach(item => {
    if (item && item.id && !seenIds.has(item.id)) {
    seenIds.add(item.id);
    uniqueContent.push(item);
    }
    });

    return uniqueContent.slice(0, params.limit || 20);
    } else if (data.results) {
    return Array.isArray(data.results) ? data.results : [];
    } else if (Array.isArray(data)) {
    return data;
    } else {
    console.warn('Unexpected response structure:', data);
    return [];
    }
    } catch (error) {
    console.error('Fetch error:', error);
    throw error;
    }
    }

    /**
    * Setup carousel navigation
    */
    setupCarouselNavigation(carouselRow) {
    const wrapper = carouselRow.querySelector('.carousel-wrapper');
    const prevBtn = carouselRow.querySelector('.carousel-nav.prev');
    const nextBtn = carouselRow.querySelector('.carousel-nav.next');

    if (!wrapper) return;

    const getScrollAmount = () => {
    const containerWidth = wrapper.clientWidth;
    const cardWidth = wrapper.querySelector('.content-card')?.offsetWidth || 180;
    const gap = parseInt(getComputedStyle(wrapper).gap) || 12;
    const visibleCards = Math.floor(containerWidth / (cardWidth + gap));
    return (cardWidth + gap) * Math.max(1, visibleCards - 1);
    };

    const updateNavButtons = () => {
    if (!prevBtn || !nextBtn) return;
    const scrollLeft = wrapper.scrollLeft;
    const maxScroll = wrapper.scrollWidth - wrapper.clientWidth;
    prevBtn.classList.toggle('disabled', scrollLeft <= 0); nextBtn.classList.toggle('disabled', scrollLeft>= maxScroll -
        1);
        };

        if (prevBtn && nextBtn) {
        prevBtn.addEventListener('click', () => {
        wrapper.scrollBy({ left: -getScrollAmount(), behavior: 'smooth' });
        });

        nextBtn.addEventListener('click', () => {
        wrapper.scrollBy({ left: getScrollAmount(), behavior: 'smooth' });
        });

        wrapper.addEventListener('scroll', updateNavButtons);
        updateNavButtons();
        }

        this.setupTouchScroll(wrapper);
        }

        /**
        * Setup touch scrolling for carousels
        */
        setupTouchScroll(wrapper) {
        let isDown = false;
        let startX = 0;
        let scrollLeft = 0;

        // Touch events
        wrapper.addEventListener('touchstart', (e) => {
        isDown = true;
        startX = e.touches[0].pageX;
        scrollLeft = wrapper.scrollLeft;
        }, { passive: true });

        wrapper.addEventListener('touchmove', (e) => {
        if (!isDown) return;
        const x = e.touches[0].pageX;
        const walk = (startX - x) * 1.5;
        wrapper.scrollLeft = scrollLeft + walk;
        }, { passive: true });

        wrapper.addEventListener('touchend', () => {
        isDown = false;
        });

        // Mouse events for desktop
        wrapper.addEventListener('mousedown', (e) => {
        isDown = true;
        startX = e.pageX;
        scrollLeft = wrapper.scrollLeft;
        wrapper.style.cursor = 'grabbing';
        });

        wrapper.addEventListener('mousemove', (e) => {
        if (!isDown) return;
        e.preventDefault();
        const x = e.pageX;
        const walk = (startX - x) * 2;
        wrapper.scrollLeft = scrollLeft + walk;
        });

        wrapper.addEventListener('mouseup', () => {
        isDown = false;
        wrapper.style.cursor = 'grab';
        });

        wrapper.addEventListener('mouseleave', () => {
        isDown = false;
        wrapper.style.cursor = 'grab';
        });
        }

        /**
        * Setup event listeners
        */
        setupEventListeners() {
        // Handle window resize
        let resizeTimer;
        window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
        document.querySelectorAll('.content-row').forEach(row => {
        this.setupCarouselNavigation(row);
        });
        }, 250);
        });

        // Listen for auth changes
        window.addEventListener('storage', (e) => {
        if (e.key === 'cinebrain-token') {
        this.authToken = e.newValue;
        this.isAuthenticated = !!this.authToken;
        if (this.isAuthenticated) {
        this.loadUserWishlist();
        } else {
        this.userWishlist.clear();
        this.interactionStates.clear();
        }
        this.updateWishlistButtons();
        }
        });

        // Sync wishlist state when page becomes visible again
        document.addEventListener('visibilitychange', () => {
        if (!document.hidden && this.isAuthenticated) {
        this.syncWishlistState();
        }
        });

        // Sync wishlist state when window gains focus
        window.addEventListener('focus', () => {
        if (this.isAuthenticated) {
        this.syncWishlistState();
        }
        });
        }

        /**
        * Handle wishlist click - Using custom notification system
        */
        async handleWishlistClick(contentId, button) {
        if (!this.isAuthenticated) {
        this.showNotification('Please login to add to wishlist', 'warning');
        setTimeout(() => {
        window.location.href = '/auth/login.html?redirect=' + encodeURIComponent(window.location.pathname);
        }, 1000);
        return;
        }

        try {
        // Check current state
        const isCurrentlyInWishlist = button?.classList.contains('active') ||
        button?.classList.contains('added') ||
        this.userWishlist.has(contentId);

        // Prevent double clicks
        if (button && button.disabled) return;
        if (button) button.disabled = true;

        // For removing from wishlist
        if (isCurrentlyInWishlist) {
        // First, try to remove using DELETE method
        try {
        const deleteResponse = await fetch(`${this.apiBase}/user/watchlist/${contentId}`, {
        method: 'DELETE',
        headers: {
        'Authorization': `Bearer ${this.authToken}`
        }
        });

        if (deleteResponse.ok || deleteResponse.status === 404) {
        // Successfully removed or already removed
        this.updateWishlistUIAfterRemove(contentId, button);
        this.showNotification('Removed from wishlist', 'success', 2000);
        return;
        }
        } catch (deleteError) {
        console.log('DELETE method not supported, trying alternative method');
        }

        // Fallback: Record removal interaction
        const removeResponse = await fetch(`${this.apiBase}/interactions`, {
        method: 'POST',
        headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.authToken}`
        },
        body: JSON.stringify({
        content_id: contentId,
        interaction_type: 'remove_watchlist'
        })
        });

        if (removeResponse.ok) {
        this.updateWishlistUIAfterRemove(contentId, button);
        this.showNotification('Removed from wishlist', 'success', 2000);
        } else {
        throw new Error('Failed to remove from wishlist');
        }
        } else {
        // Add to wishlist
        const response = await fetch(`${this.apiBase}/interactions`, {
        method: 'POST',
        headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.authToken}`
        },
        body: JSON.stringify({
        content_id: contentId,
        interaction_type: 'watchlist'
        })
        });

        if (!response.ok) {
        throw new Error(`Failed to add to wishlist: ${response.status}`);
        }

        this.updateWishlistUIAfterAdd(contentId, button);
        this.showNotification('Added to wishlist', 'success', 2000);
        }

        // Update hero button if it's the same content
        this.updateHeroWishlistButton(contentId);

        } catch (error) {
        this.showNotification('Failed to update wishlist', 'error');
        console.error('Error updating wishlist:', error);
        } finally {
        // Re-enable button after a short delay
        if (button) {
        setTimeout(() => {
        button.disabled = false;
        }, 500);
        }
        }
        }

        /**
        * Update UI after adding to wishlist
        */
        updateWishlistUIAfterAdd(contentId, button) {
        this.userWishlist.add(contentId);
        this.interactionStates.set(contentId, 'watchlist');

        if (button) {
        if (button.classList.contains('wishlist-btn-top10')) {
        button.classList.add('added');
        button.textContent = '✓ Added';
        } else {
        button.classList.add('active');
        }
        button.setAttribute('title', 'Remove from Wishlist');
        button.setAttribute('aria-label', 'Remove from Wishlist');
        }

        // Update all buttons for this content
        this.updateAllWishlistButtonsForContent(contentId, true);
        }

        /**
        * Update UI after removing from wishlist
        */
        updateWishlistUIAfterRemove(contentId, button) {
        this.userWishlist.delete(contentId);
        this.interactionStates.delete(contentId);

        if (button) {
        if (button.classList.contains('wishlist-btn-top10')) {
        button.classList.remove('added');
        button.textContent = '+ Add';
        } else {
        button.classList.remove('active');
        }
        button.setAttribute('title', 'Add to Wishlist');
        button.setAttribute('aria-label', 'Add to Wishlist');
        }

        // Update all buttons for this content
        this.updateAllWishlistButtonsForContent(contentId, false);
        }

        /**
        * Update all wishlist buttons for a specific content
        */
        updateAllWishlistButtonsForContent(contentId, isInWishlist) {
        // Update all wishlist buttons for this content ID
        document.querySelectorAll(`[data-content-id="${contentId}"]`).forEach(btn => {
        if (btn.classList.contains('wishlist-btn')) {
        btn.classList.toggle('active', isInWishlist);
        btn.setAttribute('title', isInWishlist ? 'Remove from Wishlist' : 'Add to Wishlist');
        btn.setAttribute('aria-label', isInWishlist ? 'Remove from Wishlist' : 'Add to Wishlist');
        } else if (btn.classList.contains('wishlist-btn-top10')) {
        btn.classList.toggle('added', isInWishlist);
        btn.textContent = isInWishlist ? '✓ Added' : '+ Add';
        btn.setAttribute('title', isInWishlist ? 'Remove from Wishlist' : 'Add to Wishlist');
        }
        });
        }

        /**
        * Update hero wishlist button
        */
        updateHeroWishlistButton(contentId) {
        const heroWatchlistBtn = document.getElementById('heroWatchlistBtn');
        if (!heroWatchlistBtn) return;

        // Check if hero content matches the updated content
        const heroContentId = parseInt(heroWatchlistBtn.dataset.contentId || '0');
        if (heroContentId !== contentId) return;

        const isInWishlist = this.userWishlist.has(contentId);
        heroWatchlistBtn.textContent = isInWishlist ? '✓ In List' : '+ My List';
        heroWatchlistBtn.classList.toggle('added', isInWishlist);
        }

        /**
        * Update all wishlist buttons
        */
        updateWishlistButtons() {
        // Update all wishlist buttons based on current state
        document.querySelectorAll('.wishlist-btn, .wishlist-btn-top10').forEach(btn => {
        const contentId = parseInt(btn.dataset.contentId);
        const isInWishlist = this.userWishlist.has(contentId);

        if (btn.classList.contains('wishlist-btn-top10')) {
        btn.classList.toggle('added', isInWishlist);
        btn.textContent = isInWishlist ? '✓ Added' : '+ Add';
        } else {
        btn.classList.toggle('active', isInWishlist);
        }

        btn.setAttribute('title', isInWishlist ? 'Remove from Wishlist' : 'Add to Wishlist');
        btn.setAttribute('aria-label', isInWishlist ? 'Remove from Wishlist' : 'Add to Wishlist');
        });

        // Update hero button
        const heroWatchlistBtn = document.getElementById('heroWatchlistBtn');
        if (heroWatchlistBtn) {
        const heroContentId = parseInt(heroWatchlistBtn.dataset.contentId || '0');
        if (heroContentId && this.userWishlist.has(heroContentId)) {
        heroWatchlistBtn.textContent = '✓ In List';
        heroWatchlistBtn.classList.add('added');
        }
        }
        }

        /**
        * Redirect to details page
        */
        redirectToDetails(content) {
        // Store content data for the details page
        sessionStorage.setItem('contentDetails', JSON.stringify(content));

        // Redirect to details page
        const contentType = content.content_type || 'movie';
        const contentId = content.id;

        window.location.href = `/content/details.html?id=${contentId}&type=${contentType}`;
        }

        // Utility methods
        /**
        * Format poster URL
        */
        formatPosterUrl(posterPath) {
        if (!posterPath) {
        return this.getPlaceholderImage();
        }
        if (posterPath.startsWith('http')) return posterPath;
        return `${this.posterBase}${posterPath}`;
        }

        /**
        * Get placeholder image
        */
        getPlaceholderImage() {
        return
        'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjQ1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjQ1MCIgZmlsbD0iIzFhMWYzYSIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmaWxsPSIjNjY3IiBmb250LXNpemU9IjE4IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+';
        }

        /**
        * Format rating
        */
        formatRating(rating) {
        if (!rating) return 'N/A';
        return Number(rating).toFixed(1);
        }

        /**
        * Extract year from date string
        */
        extractYear(dateString) {
        if (!dateString) return '';
        try {
        return new Date(dateString).getFullYear();
        } catch {
        return '';
        }
        }

        /**
        * Format runtime
        */
        formatRuntime(minutes) {
        if (!minutes) return '';
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        return hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
        }

        /**
        * Escape HTML
        */
        escapeHtml(text) {
        if (!text || typeof text !== 'string') return '';
        const map = {
        '&': '&amp;',
        '<': '&lt;' , '>' : '&gt;' , '"' : '&quot;' , "'" : '&#039;' }; return text.replace(/[&<>"']/g, m => map[m]);
            }

            /**
            * Refresh page data
            */
            async refresh() {
            console.log('Refreshing trending page...');

            // Clear caches
            this.contentCache.clear();

            // Reload hero content
            this.showHeroSkeleton();
            await this.loadHeroContent();

            // Reload all content rows
            this.contentRows.forEach((rowConfig, index) => {
            const row = document.getElementById(rowConfig.id);
            if (row) {
            const wrapper = row.querySelector('.carousel-wrapper');
            if (wrapper) {
            wrapper.innerHTML = this.createSkeletons(8);
            setTimeout(() => {
            this.loadContentRow(rowConfig);
            }, index * 100);
            }
            }
            });

            // Reload top 10
            this.showTop10Skeleton();
            setTimeout(() => {
            this.loadTop10List();
            }, this.contentRows.length * 100);
            }

            /**
            * Handle page visibility for performance optimization
            */
            handleVisibilityChange() {
            if (document.visibilityState === 'visible' && this.isAuthenticated) {
            // Sync wishlist when page becomes visible
            this.syncWishlistState();
            }
            }

            /**
            * Handle online/offline events
            */
            handleOnlineStatus() {
            if (navigator.onLine) {
            console.log('Connection restored, refreshing content...');
            this.refresh();
            this.showNotification('Connection restored', 'success', 2000);
            } else {
            this.showNotification('You are offline. Some features may not work.', 'warning', 5000);
            }
            }

            /**
            * Destroy component
            */
            destroy() {
            // Clear timers and observers
            if (this.resizeTimer) {
            clearTimeout(this.resizeTimer);
            }

            // Clear caches
            this.contentCache.clear();
            this.userWishlist.clear();
            this.interactionStates.clear();

            console.log('Trending page manager destroyed');
            }
            }

            // Initialize Trending Page Manager
            const trendingManager = new TrendingPageManager();

            // Make it globally available
            window.trendingManager = trendingManager;

            // Export for module usage
            if (typeof module !== 'undefined' && module.exports) {
            module.exports = TrendingPageManager;
            }

            // Initialize on DOM ready
            document.addEventListener('DOMContentLoaded', function () {
            console.log('Trending page DOM loaded successfully!');

            // Ensure body theme attributes are set
            const savedTheme = localStorage.getItem('cinebrain-theme') || 'dark';
            document.body.setAttribute('data-theme', savedTheme);
            document.body.setAttribute('data-bs-theme', savedTheme);

            // Add page-specific class
            document.body.classList.add('trending-page');
            });

            // Handle page visibility changes for performance
            document.addEventListener('visibilitychange', function () {
            if (window.trendingManager) {
            window.trendingManager.handleVisibilityChange();
            }
            });

            // Handle online/offline events
            window.addEventListener('online', function () {
            if (window.trendingManager) {
            window.trendingManager.handleOnlineStatus();
            }
            });

            window.addEventListener('offline', function () {
            if (window.trendingManager) {
            window.trendingManager.handleOnlineStatus();
            }
            });

            // Memory cleanup on page unload
            window.addEventListener('beforeunload', function () {
            if (window.trendingManager) {
            window.trendingManager.destroy();
            }
            });